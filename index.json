[{"categories":["框架"],"content":"SpringMVC ssm：mybatis + Spring + SpringMVC MVC三层架构 JavaSE：认真学习， 老师带，入门快 JavaWeb：认真学习，老师带，入门快 SSM框架：研究官方文档,锻炼自学能力，锻炼笔记能力，锻炼项目能力 SpringMVC + Vue +SpringBoot + SpringCloud + Linux SSM = javaWeb做项目 Spring：IOC和AOP SpringMVC：SpringMVC的执行流程！ SpringMVC ：SSM框架整合！ MVC：模型（dao，service） 视图 （jsp）控制器（Servlet） dao service servlet：转发，重定向 jsp/html JSP ：本质上就是一个Servlet 假设：你的项目的架构，是设计好的，还是演进的？ 一定是演进的 ","date":"2021-09-21","objectID":"/springmvc/:0:0","tags":["SpringMVC","SSM整合"],"title":"SpringMVC","uri":"/springmvc/"},{"categories":["框架"],"content":"回顾servlet 导入依赖 \u003c!--导入依赖--\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003ejunit\u003c/groupId\u003e \u003cartifactId\u003ejunit\u003c/artifactId\u003e \u003cversion\u003e4.13\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-webmvc\u003c/artifactId\u003e \u003cversion\u003e5.3.9\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ejavax.servlet\u003c/groupId\u003e \u003cartifactId\u003eservlet-api\u003c/artifactId\u003e \u003cversion\u003e2.5\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ejavax.servlet\u003c/groupId\u003e \u003cartifactId\u003ejstl\u003c/artifactId\u003e \u003cversion\u003e1.2\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e 有一个jsp-api没有 建立servlet package com.miaobuyi.servlet; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; public class HelloServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { resp.setContentType(\"text/html;charset=utf-8\");//解决中文乱码 //1.获取前端参数 String method = req.getParameter(\"method\" ); if (method.equals(\"add\")) { req.getSession().setAttribute(\"msg\", \"执行了add方法\"); if (method.equals(\"delete\")) { req.getSession().setAttribute(\"msg\", \"执行了delete方法\"); } } //2.调用业务层 //3.视图转发或者重定向 req.getRequestDispatcher(\"/WEB-INF/jsp/test.jsp\").forward(req,resp); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req, resp); } } web.xml中注册servlet \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cweb-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"\u003e \u003cservlet\u003e \u003cservlet-name\u003ehello\u003c/servlet-name\u003e \u003cservlet-class\u003ecom.miaobuyi.servlet.HelloServlet\u003c/servlet-class\u003e \u003c/servlet\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003ehello\u003c/servlet-name\u003e \u003curl-pattern\u003e/hello\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e \u003cwelcome-file-list\u003e \u003cwelcome-file\u003eindex.jsp\u003c/welcome-file\u003e \u003c/welcome-file-list\u003e \u003c/web-app\u003e 在前端中发起请求 \u003c%-- Created by IntelliJ IDEA. User: 杨宇 Date: 2021/9/13 Time: 9:55 To change this template use File | Settings | File Templates. --%\u003e \u003c%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %\u003e \u003chtml\u003e \u003chead\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cform action=\"/hello\" method=\"post\"\u003e \u003cinput type=\"text\" name=\"method\"\u003e \u003cinput type=\"submit\"\u003e \u003c/form\u003e \u003c/body\u003e \u003c/html\u003e MVC框架要做哪些事情 将ur|映射到java类或java类的方法 封装用户提交的数据 处理请求–调用相关的业务处理–封装响应数据 将响应的数据进行渲染. jsp/ html等表示层数据 SrpingMVC的特点： 轻量级，简单易学 高效，基于请求响应的MVC框架 与Spring兼容性好，无缝集合 约定优于配置 功能强大：RESTful，数据验证，格式化，本地化，主题等 简介灵活 ","date":"2021-09-21","objectID":"/springmvc/:1:0","tags":["SpringMVC","SSM整合"],"title":"SpringMVC","uri":"/springmvc/"},{"categories":["框架"],"content":"一、第一个MVC程序 ","date":"2021-09-21","objectID":"/springmvc/:2:0","tags":["SpringMVC","SSM整合"],"title":"SpringMVC","uri":"/springmvc/"},{"categories":["框架"],"content":"配置版 1、新建一个Moudle ， springmvc-02-hello ， 添加web的支持！ 2、确定导入了SpringMVC 的依赖！ 3、配置web.xml ， 注册DispatcherServlet \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cweb-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"\u003e \u003c!--1.注册DispatcherServlet--\u003e \u003cservlet\u003e \u003cservlet-name\u003espringmvc\u003c/servlet-name\u003e \u003cservlet-class\u003eorg.springframework.web.servlet.DispatcherServlet\u003c/servlet-class\u003e \u003c!--关联一个springmvc的配置文件:【servlet-name】-servlet.xml--\u003e \u003cinit-param\u003e \u003cparam-name\u003econtextConfigLocation\u003c/param-name\u003e \u003cparam-value\u003eclasspath:springmvc-servlet.xml\u003c/param-value\u003e \u003c/init-param\u003e \u003c!--启动级别-1--\u003e \u003cload-on-startup\u003e1\u003c/load-on-startup\u003e \u003c/servlet\u003e \u003c!--/ 匹配所有的请求；（不包括.jsp）--\u003e \u003c!--/* 匹配所有的请求；（包括.jsp）--\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003espringmvc\u003c/servlet-name\u003e \u003curl-pattern\u003e/\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e \u003c/web-app\u003e 4、编写SpringMVC 的 配置文件！名称：springmvc-servlet.xml : [servletname]-servlet.xml 说明，这里的名称要求是按照官方来的 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u003c/beans\u003e 5、添加 处理器映射器 \u003cbean class=\"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\"/\u003e 6、添加 处理器适配器 \u003cbean class=\"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter\"/\u003e 7、添加 视图解析器 \u003c!--视图解析器:DispatcherServlet给他的ModelAndView--\u003e \u003cbean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" id=\"InternalResourceViewResolver\"\u003e \u003c!--前缀--\u003e \u003cproperty name=\"prefix\" value=\"/WEB-INF/jsp/\"/\u003e \u003c!--后缀--\u003e \u003cproperty name=\"suffix\" value=\".jsp\"/\u003e \u003c/bean\u003e 8、编写我们要操作业务Controller ，要么实现Controller接口，要么增加注解；需要返回一个ModelAndView，装数据，封视图； package com.kuang.controller; import org.springframework.web.servlet.ModelAndView; import org.springframework.web.servlet.mvc.Controller; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; //注意：这里我们先导入Controller接口 public class HelloController implements Controller { public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception { //ModelAndView 模型和视图 ModelAndView mv = new ModelAndView(); //封装对象，放在ModelAndView中。Model mv.addObject(\"msg\",\"HelloSpringMVC!\"); //封装要跳转的视图，放在ModelAndView中 mv.setViewName(\"hello\"); //: /WEB-INF/jsp/hello.jsp return mv; } } 9、将自己的类交给SpringIOC容器，注册bean \u003c!--Handler--\u003e \u003cbean id=\"/hello\" class=\"com.kuang.controller.HelloController\"/\u003e 10、写要跳转的jsp页面，显示ModelandView存放的数据，以及我们的正常页面； \u003c%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %\u003e \u003chtml\u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e ${msg} \u003c/body\u003e \u003c/html\u003e 11、配置Tomcat 启动测试！ 可能遇到的问题：访问出现404，排查步骤： 查看控制台输出，看一下是不是缺少了什么jar包。 如果jar包存在，显示无法输出，就在IDEA的项目发布中，添加lib依赖！ 重启Tomcat 即可解决！ 小结：看这个估计大部分同学都能理解其中的原理了，但是我们实际开发才不会这么写，不然就疯了，还学这个玩意干嘛！我们来看个注解版实现，这才是SpringMVC的精髓，到底有多么简单，看这个图就知道了。 ","date":"2021-09-21","objectID":"/springmvc/:2:1","tags":["SpringMVC","SSM整合"],"title":"SpringMVC","uri":"/springmvc/"},{"categories":["框架"],"content":"注解版 1、新建一个Moudle，springmvc-03-hello-annotation 。添加web支持！ 2、由于Maven可能存在资源过滤的问题，我们将配置完善 \u003cbuild\u003e \u003cresources\u003e \u003cresource\u003e \u003cdirectory\u003esrc/main/java\u003c/directory\u003e \u003cincludes\u003e \u003cinclude\u003e**/*.properties\u003c/include\u003e \u003cinclude\u003e**/*.xml\u003c/include\u003e \u003c/includes\u003e \u003cfiltering\u003efalse\u003c/filtering\u003e \u003c/resource\u003e \u003cresource\u003e \u003cdirectory\u003esrc/main/resources\u003c/directory\u003e \u003cincludes\u003e \u003cinclude\u003e**/*.properties\u003c/include\u003e \u003cinclude\u003e**/*.xml\u003c/include\u003e \u003c/includes\u003e \u003cfiltering\u003efalse\u003c/filtering\u003e \u003c/resource\u003e \u003c/resources\u003e \u003c/build\u003e 3、在pom.xml文件引入相关的依赖：主要有Spring框架核心库、Spring MVC、servlet , JSTL等。我们在父依赖中已经引入了！ 4、配置web.xml 注意点： \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cweb-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"\u003e \u003c!--1.注册servlet--\u003e \u003cservlet\u003e \u003cservlet-name\u003eSpringMVC\u003c/servlet-name\u003e \u003cservlet-class\u003eorg.springframework.web.servlet.DispatcherServlet\u003c/servlet-class\u003e \u003c!--通过初始化参数指定SpringMVC配置文件的位置，进行关联--\u003e \u003cinit-param\u003e \u003cparam-name\u003econtextConfigLocation\u003c/param-name\u003e \u003cparam-value\u003eclasspath:springmvc-servlet.xml\u003c/param-value\u003e \u003c/init-param\u003e \u003c!-- 启动顺序，数字越小，启动越早 --\u003e \u003cload-on-startup\u003e1\u003c/load-on-startup\u003e \u003c/servlet\u003e \u003c!--所有请求都会被springmvc拦截 --\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003eSpringMVC\u003c/servlet-name\u003e \u003curl-pattern\u003e/\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e \u003c/web-app\u003e / 和 /* 的区别：\u003c url-pattern \u003e / \u003c/ url-pattern \u003e 不会匹配到.jsp， 只针对我们编写的请求；即：.jsp 不会进入spring的 DispatcherServlet类 。\u003c url-pattern \u003e /* \u003c/ url-pattern \u003e 会匹配 *.jsp，会出现返回 jsp视图 时再次进入spring的DispatcherServlet 类，导致找不到对应的controller所以报404错。 注意web.xml版本问题，要最新版！ 注册DispatcherServlet 关联SpringMVC的配置文件 启动级别为1 映射路径为 / 【不要用/*，会404】 5、添加Spring MVC配置文件 在resource目录下添加springmvc-servlet.xml配置文件，配置的形式与Spring容器配置基本类似，为了支持基于注解的IOC，设置了自动扫描包的功能，具体配置信息如下： \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\"\u003e \u003c!-- 自动扫描包，让指定包下的注解生效,由IOC容器统一管理 --\u003e \u003ccontext:component-scan base-package=\"com.kuang.controller\"/\u003e \u003c!-- 让Spring MVC不处理静态资源 --\u003e \u003cmvc:default-servlet-handler /\u003e \u003c!-- 支持mvc注解驱动 在spring中一般采用@RequestMapping注解来完成映射关系 要想使@RequestMapping注解生效 必须向上下文中注册DefaultAnnotationHandlerMapping 和一个AnnotationMethodHandlerAdapter实例 这两个实例分别在类级别和方法级别处理。 而annotation-driven配置帮助我们自动完成上述两个实例的注入。 --\u003e \u003cmvc:annotation-driven /\u003e \u003c!-- 视图解析器 --\u003e \u003cbean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" id=\"internalResourceViewResolver\"\u003e \u003c!-- 前缀 --\u003e \u003cproperty name=\"prefix\" value=\"/WEB-INF/jsp/\" /\u003e \u003c!-- 后缀 --\u003e \u003cproperty name=\"suffix\" value=\".jsp\" /\u003e \u003c/bean\u003e \u003c/beans\u003e 在视图解析器中我们把所有的视图都存放在/WEB-INF/目录下，这样可以保证视图安全，因为这个目录下的文件，客户端不能直接访问。 让IOC的注解生效 静态资源过滤 ：HTML . JS . CSS . 图片 ， 视频 ….. MVC的注解驱动 配置视图解析器 6、创建Controller 编写一个Java控制类：com.kuang.controller.HelloController , 注意编码规范 package com.kuang.controller; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.RequestMapping; @Controller @RequestMapping(\"/HelloController\") public class HelloController { //真实访问地址 : 项目名/HelloController/hello @RequestMapping(\"/hello\") public String sayHello(Model model){ //向模型中添加属性msg与值，可以在JSP页面中取出并渲染 model.addAttribute(\"msg\",\"hello,SpringMVC\"); //web-inf/jsp/hello.jsp return \"hello\"; } } @Controller是为了让Spring IOC容器初始化时自动扫描到； @RequestMapping是为了映射请求路径，这里因为类与方法上都有映射所以访问时应该是/HelloController/hello； 方法中声明Model类型的参数是为了把Action中的数据带到视图中； 方法返回的结果是视图的名称hello，加上配置文件中的前后缀变成WEB-INF/jsp/hello.jsp。 7、创建视图层 在WEB-INF/ jsp目录中创建hello.jsp ， 视图可以直接取出并展示从","date":"2021-09-21","objectID":"/springmvc/:2:2","tags":["SpringMVC","SSM整合"],"title":"SpringMVC","uri":"/springmvc/"},{"categories":["框架"],"content":"小结 实现步骤其实非常的简单： 新建一个web项目 导入相关jar包 编写web.xml , 注册DispatcherServlet 编写springmvc配置文件 接下来就是去创建对应的控制类 , controller 最后完善前端视图和controller之间的对应 测试运行调试. 使用springMVC必须配置的三大件： 处理器映射器、处理器适配器、视图解析器 通常，我们只需要手动配置视图解析器，而处理器映射器和处理器适配器只需要开启注解驱动即可，而省去了大段的xml配置 再来回顾下原理吧~ 简要分析执行流程 DispatcherServlet表示前置控制器，是整个SpringMVC的控制中心。户发出请求, DispatcherServlet接收请求并拦截请求。 我们假设请求的url为: http://localhost:8080/SpringMVC/hello 如上url拆分成三部分: http://localhost:8080服务器域名 SpringMVC部署在服务器.上的web站点 hello表示控制器 通过分析，如上urI表示为:请求位于服务器localhost:8080上的SpringMVC站点的hello控制器。 HandlerMapping为处理器映射。DispatcherServlet调用 HandlerMa pping, HandlerMapping根据请求url查找Handler。 HandlerExecution表示具体的Handler,其主要作用是根据ur|查找控制器，如， 上url被查找控制器 为: hello。 HandlerExecution将解析后的信息传递给DispatcherServlet,如解析控制器映射等。 HandlerAdapter表示处理器适配器，其按照特定的规则去执行Handler。 Handler让具体的Controller执行。 ","date":"2021-09-21","objectID":"/springmvc/:2:3","tags":["SpringMVC","SSM整合"],"title":"SpringMVC","uri":"/springmvc/"},{"categories":["框架"],"content":"二、Controller及RestFul风格 ","date":"2021-09-21","objectID":"/springmvc/:3:0","tags":["SpringMVC","SSM整合"],"title":"SpringMVC","uri":"/springmvc/"},{"categories":["框架"],"content":"控制器Controller 控制器复杂提供访问应用程序的行为，通常通过接口定义或注解定义两种方法实现。 控制器负责解析用户的请求并将其转换为一个模型。 在Spring MVC中一个控制器类可以包含多个方法 在Spring MVC中，对于Controller的配置方式有很多种 ","date":"2021-09-21","objectID":"/springmvc/:3:1","tags":["SpringMVC","SSM整合"],"title":"SpringMVC","uri":"/springmvc/"},{"categories":["框架"],"content":"实现Controller接口 Controller是一个接口，在org.springframework.web.servlet.mvc包下，接口中只有一个方法； //实现该接口的类获得控制器功能 public interface Controller { //处理请求且返回一个模型与视图对象 ModelAndView handleRequest(HttpServletRequest var1, HttpServletResponse var2) throws Exception; } 测试 新建一个Moudle，springmvc-04-controller 。将刚才的03 拷贝一份, 我们进行操作！ 删掉HelloController mvc的配置文件只留下 视图解析器！ 编写一个Controller类，ControllerTest1 //定义控制器 //注意点：不要导错包，实现Controller接口，重写方法； public class ControllerTest1 implements Controller { public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception { //返回一个模型视图对象 ModelAndView mv = new ModelAndView(); mv.addObject(\"msg\",\"Test1Controller\"); mv.setViewName(\"test\"); return mv; } } 编写完毕后，去Spring配置文件中注册请求的bean；name对应请求路径，class对应处理请求的类 \u003cbean name=\"/t1\" class=\"com.kuang.controller.ControllerTest1\"/\u003e 编写前端test.jsp，注意在WEB-INF/jsp目录下编写，对应我们的视图解析器 \u003c%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %\u003e \u003chtml\u003e \u003chead\u003e \u003ctitle\u003eKuangshen\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e ${msg} \u003c/body\u003e \u003c/html\u003e 配置Tomcat运行测试，我这里没有项目发布名配置的就是一个 / ，所以请求不用加项目名，OK！ 说明： 实现接口Controller定义控制器是较老的办法 缺点是：一个控制器中只有一个方法，如果要多个方法则需要定义多个Controller；定义的方式比较麻烦； ","date":"2021-09-21","objectID":"/springmvc/:3:2","tags":["SpringMVC","SSM整合"],"title":"SpringMVC","uri":"/springmvc/"},{"categories":["框架"],"content":"使用注解@Controller @Controller注解类型用于声明Spring类的实例是一个控制器（在讲IOC时还提到了另外3个注解）； Spring可以使用扫描机制来找到应用程序中所有基于注解的控制器类，为了保证Spring能找到你的控制器，需要在配置文件中声明组件扫描。 \u003c!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --\u003e \u003ccontext:component-scan base-package=\"com.kuang.controller\"/\u003e 增加一个ControllerTest2类，使用注解实现； //@Controller注解的类会自动添加到Spring上下文中 @Controller public class ControllerTest2{ //映射访问路径 @RequestMapping(\"/t2\") public String index(Model model){ //Spring MVC会自动实例化一个Model对象用于向视图中传值 model.addAttribute(\"msg\", \"ControllerTest2\"); //返回视图位置 return \"test\"; } } 运行tomcat测试 可以发现，我们的两个请求都可以指向一个视图，但是页面结果的结果是不一样的，从这里可以看出视图是被复用的，而控制器与视图之间是弱偶合关系。 注解方式是平时使用的最多的方式！ ","date":"2021-09-21","objectID":"/springmvc/:3:3","tags":["SpringMVC","SSM整合"],"title":"SpringMVC","uri":"/springmvc/"},{"categories":["框架"],"content":"RequestMapping @RequestMapping @RequestMapping注解用于映射url到控制器类或一个特定的处理程序方法。可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。 为了测试结论更加准确，我们可以加上一个项目名测试 myweb 只注解在方法上面 @Controller public class TestController { @RequestMapping(\"/h1\") public String test(){ return \"test\"; } } 访问路径：http://localhost:8080 / 项目名 / h1 同时注解类与方法 @Controller @RequestMapping(\"/admin\") public class TestController { @RequestMapping(\"/h1\") public String test(){ return \"test\"; } } 访问路径：http://localhost:8080 / 项目名/ admin /h1 , 需要先指定类的路径再指定方法的路径； ","date":"2021-09-21","objectID":"/springmvc/:3:4","tags":["SpringMVC","SSM整合"],"title":"SpringMVC","uri":"/springmvc/"},{"categories":["框架"],"content":"RestFul 风格 概念 Restful就是一个资源定位及资源操作的风格。不是标准也不是协议，只是一种风格。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。 功能 资源：互联网所有的事物都可以被抽象为资源 资源操作：使用POST、DELETE、PUT、GET，使用不同方法对资源进行操作。 分别对应 添加、 删除、修改、查询。 传统方式操作资源 ：通过不同的参数来实现不同的效果！方法单一，post 和 get ​ http://127.0.0.1/item/queryItem.action?id=1 查询,GET ​ http://127.0.0.1/item/saveItem.action 新增,POST ​ http://127.0.0.1/item/updateItem.action 更新,POST ​ http://127.0.0.1/item/deleteItem.action?id=1 删除,GET或POST 使用RESTful操作资源 ：可以通过不同的请求方式来实现不同的效果！如下：请求地址一样，但是功能可以不同！ ​ http://127.0.0.1/item/1 查询,GET ​ http://127.0.0.1/item 新增,POST ​ http://127.0.0.1/item 更新,PUT ​ http://127.0.0.1/item/1 删除,DELETE 学习测试 在新建一个类 RestFulController @Controller public class RestFulController { } 在Spring MVC中可以使用 @PathVariable 注解，让方法参数的值对应绑定到一个URI模板变量上。 @Controller public class RestFulController { //映射访问路径 @RequestMapping(\"/commit/{p1}/{p2}\") public String index(@PathVariable int p1, @PathVariable int p2, Model model){ int result = p1+p2; //Spring MVC会自动实例化一个Model对象用于向视图中传值 model.addAttribute(\"msg\", \"结果：\"+result); //返回视图位置 return \"test\"; } } 我们来测试请求查看下 思考：使用路径变量的好处？ 使路径变得更加简洁； 获得参数更加方便，框架会自动进行类型转换。 通过路径变量的类型可以约束访问参数，如果类型不一样，则访问不到对应的请求方法，如这里访问是的路径是/commit/1/a，则路径与方法不匹配，而不会是参数转换失败。 我们来修改下对应的参数类型，再次测试 //映射访问路径 @RequestMapping(\"/commit/{p1}/{p2}\") public String index(@PathVariable int p1, @PathVariable String p2, Model model){ String result = p1+p2; //Spring MVC会自动实例化一个Model对象用于向视图中传值 model.addAttribute(\"msg\", \"结果：\"+result); //返回视图位置 return \"test\"; } 使用method属性指定请求类型 用于约束请求的类型，可以收窄请求范围。指定请求谓词的类型如GET, POST, HEAD, OPTIONS, PUT, PATCH, DELETE, TRACE等 我们来测试一下： 增加一个方法 //映射访问路径,必须是POST请求 @RequestMapping(value = \"/hello\",method = {RequestMethod.POST}) public String index2(Model model){ model.addAttribute(\"msg\", \"hello!\"); return \"test\"; } 我们使用浏览器地址栏进行访问默认是Get请求，会报错405： 如果将POST修改为GET则正常了； //映射访问路径,必须是Get请求 @RequestMapping(value = \"/hello\",method = {RequestMethod.GET}) public String index2(Model model){ model.addAttribute(\"msg\", \"hello!\"); return \"test\"; } 小结： Spring MVC 的 @RequestMapping 注解能够处理 HTTP 请求的方法, 比如 GET, PUT, POST, DELETE 以及 PATCH。 所有的地址栏请求默认都会是 HTTP GET 类型的。 方法级别的注解变体有如下几个：组合注解 @GetMapping @PostMapping @PutMapping @DeleteMapping @PatchMapping @GetMapping 是一个组合注解，平时使用的会比较多！ 它所扮演的是 @RequestMapping(method =RequestMethod.GET) 的一个快捷方式。 ","date":"2021-09-21","objectID":"/springmvc/:3:5","tags":["SpringMVC","SSM整合"],"title":"SpringMVC","uri":"/springmvc/"},{"categories":["框架"],"content":"扩展：小黄鸭调试法 场景一：我们都有过向别人（甚至可能向完全不会编程的人）提问及解释编程问题的经历，但是很多时候就在我们解释的过程中自己却想到了问题的解决方案，然后对方却一脸茫然。 场景二：你的同行跑来问你一个问题，但是当他自己把问题说完，或说到一半的时候就想出答案走了，留下一脸茫然的你。 其实上面两种场景现象就是所谓的小黄鸭调试法（Rubber Duck Debuging），又称橡皮鸭调试法，它是我们软件工程中最常使用调试方法之一。 此概念据说来自《程序员修炼之道》书中的一个故事，传说程序大师随身携带一只小黄鸭，在调试代码的时候会在桌上放上这只小黄鸭，然后详细地向鸭子解释每行代码，然后很快就将问题定位修复了。 ","date":"2021-09-21","objectID":"/springmvc/:3:6","tags":["SpringMVC","SSM整合"],"title":"SpringMVC","uri":"/springmvc/"},{"categories":["框架"],"content":"三、数据处理及跳转 ","date":"2021-09-21","objectID":"/springmvc/:4:0","tags":["SpringMVC","SSM整合"],"title":"SpringMVC","uri":"/springmvc/"},{"categories":["框架"],"content":"结果跳转方式 ModelAndView 设置ModelAndView对象 , 根据view的名称 , 和视图解析器跳到指定的页面 . 页面 : {视图解析器前缀} + viewName +{视图解析器后缀} \u003c!-- 视图解析器 --\u003e \u003cbean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" id=\"internalResourceViewResolver\"\u003e \u003c!-- 前缀 --\u003e \u003cproperty name=\"prefix\" value=\"/WEB-INF/jsp/\" /\u003e \u003c!-- 后缀 --\u003e \u003cproperty name=\"suffix\" value=\".jsp\" /\u003e \u003c/bean\u003e 对应的controller类 public class ControllerTest1 implements Controller { public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception { //返回一个模型视图对象 ModelAndView mv = new ModelAndView(); mv.addObject(\"msg\",\"ControllerTest1\"); mv.setViewName(\"test\"); return mv; } } ServletAPI 通过设置ServletAPI , 不需要视图解析器 . 1、通过HttpServletResponse进行输出 2、通过HttpServletResponse实现重定向 3、通过HttpServletResponse实现转发 @Controller public class ResultGo { @RequestMapping(\"/result/t1\") public void test1(HttpServletRequest req, HttpServletResponse rsp) throws IOException { rsp.getWriter().println(\"Hello,Spring BY servlet API\"); } @RequestMapping(\"/result/t2\") public void test2(HttpServletRequest req, HttpServletResponse rsp) throws IOException { rsp.sendRedirect(\"/index.jsp\"); } @RequestMapping(\"/result/t3\") public void test3(HttpServletRequest req, HttpServletResponse rsp) throws Exception { //转发 req.setAttribute(\"msg\",\"/result/t3\"); req.getRequestDispatcher(\"/WEB-INF/jsp/test.jsp\").forward(req,rsp); } } SpringMVC 通过SpringMVC来实现转发和重定向 - 无需视图解析器； 测试前，需要将视图解析器注释掉 @Controller public class ResultSpringMVC { @RequestMapping(\"/rsm/t1\") public String test1(){ //转发 return \"/index.jsp\"; } @RequestMapping(\"/rsm/t2\") public String test2(){ //转发二 return \"forward:/index.jsp\"; } @RequestMapping(\"/rsm/t3\") public String test3(){ //重定向 return \"redirect:/index.jsp\"; } } 通过SpringMVC来实现转发和重定向 - 有视图解析器； 重定向 , 不需要视图解析器 , 本质就是重新请求一个新地方嘛 , 所以注意路径问题. 可以重定向到另外一个请求实现 . @Controller public class ResultSpringMVC2 { @RequestMapping(\"/rsm2/t1\") public String test1(){ //转发 return \"test\"; } @RequestMapping(\"/rsm2/t2\") public String test2(){ //重定向 return \"redirect:/index.jsp\"; //return \"redirect:hello.do\"; //hello.do为另一个请求/ } } ","date":"2021-09-21","objectID":"/springmvc/:4:1","tags":["SpringMVC","SSM整合"],"title":"SpringMVC","uri":"/springmvc/"},{"categories":["框架"],"content":"数据处理 处理提交数据 1、提交的域名称和处理方法的参数名一致 提交数据 : http://localhost:8080/hello?name=kuangshen 处理方法 : @RequestMapping(\"/hello\") public String hello(String name){ System.out.println(name); return \"hello\"; } 后台输出 : kuangshen 2、提交的域名称和处理方法的参数名不一致 提交数据 : http://localhost:8080/hello?username=kuangshen 处理方法 : //@RequestParam(\"username\") : username提交的域的名称 . @RequestMapping(\"/hello\") public String hello(@RequestParam(\"username\") String name){ System.out.println(name); return \"hello\"; } 后台输出 : kuangshen 3、提交的是一个对象 要求提交的表单域和对象的属性名一致 , 参数使用对象即可 1、实体类 public class User { private int id; private String name; private int age; //构造 //get/set //tostring() } 2、提交数据 : http://localhost:8080/mvc04/user?name=kuangshen\u0026id=1\u0026age=15 3、处理方法 : @RequestMapping(\"/user\") public String user(User user){ System.out.println(user); return \"hello\"; } 后台输出 : User { id=1, name=‘kuangshen’, age=15 } 说明：如果使用对象的话，前端传递的参数名和对象名必须一致，否则就是null。 数据显示到前端 第一种 : 通过ModelAndView 我们前面一直都是如此 . 就不过多解释 public class ControllerTest1 implements Controller { public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception { //返回一个模型视图对象 ModelAndView mv = new ModelAndView(); mv.addObject(\"msg\",\"ControllerTest1\"); mv.setViewName(\"test\"); return mv; } } 第二种 : 通过ModelMap ModelMap @RequestMapping(\"/hello\") public String hello(@RequestParam(\"username\") String name, ModelMap model){ //封装要显示到视图中的数据 //相当于req.setAttribute(\"name\",name); model.addAttribute(\"name\",name); System.out.println(name); return \"hello\"; } 第三种 : 通过Model Model @RequestMapping(\"/ct2/hello\") public String hello(@RequestParam(\"username\") String name, Model model){ //封装要显示到视图中的数据 //相当于req.setAttribute(\"name\",name); model.addAttribute(\"msg\",name); System.out.println(name); return \"test\"; } 对比 就对于新手而言简单来说使用区别就是： Model 只有寥寥几个方法只适合用于储存数据，简化了新手对于Model对象的操作和理解； ModelMap 继承了 LinkedMap ，除了实现了自身的一些方法，同样的继承 LinkedMap 的方法和特性； ModelAndView 可以在储存数据的同时，可以进行设置返回的逻辑视图，进行控制展示层的跳转。 当然更多的以后开发考虑的更多的是性能和优化，就不能单单仅限于此的了解。 请使用80%的时间打好扎实的基础，剩下18%的时间研究框架，2%的时间去学点英文，框架的官方文档永远是最好的教程。 ","date":"2021-09-21","objectID":"/springmvc/:4:2","tags":["SpringMVC","SSM整合"],"title":"SpringMVC","uri":"/springmvc/"},{"categories":["框架"],"content":"乱码问题 测试步骤： 1、我们可以在首页编写一个提交的表单 \u003cform action=\"/e/t\" method=\"post\"\u003e \u003cinput type=\"text\" name=\"name\"\u003e \u003cinput type=\"submit\"\u003e \u003c/form\u003e 2、后台编写对应的处理类 @Controller public class Encoding { @RequestMapping(\"/e/t\") public String test(Model model,String name){ model.addAttribute(\"msg\",name); //获取表单提交的值 return \"test\"; //跳转到test页面显示输入的值 } } 3、输入中文测试，发现乱码 不得不说，乱码问题是在我们开发中十分常见的问题，也是让我们程序猿比较头大的问题！ 以前乱码问题通过过滤器解决 , 而SpringMVC给我们提供了一个过滤器 , 可以在web.xml中配置 . 修改了xml文件需要重启服务器！ \u003cfilter\u003e \u003cfilter-name\u003eencoding\u003c/filter-name\u003e \u003cfilter-class\u003eorg.springframework.web.filter.CharacterEncodingFilter\u003c/filter-class\u003e \u003cinit-param\u003e \u003cparam-name\u003eencoding\u003c/param-name\u003e \u003cparam-value\u003eutf-8\u003c/param-value\u003e \u003c/init-param\u003e \u003c/filter\u003e \u003cfilter-mapping\u003e \u003cfilter-name\u003eencoding\u003c/filter-name\u003e \u003curl-pattern\u003e/*\u003c/url-pattern\u003e \u003c/filter-mapping\u003e 但是我们发现 , 有些极端情况下.这个过滤器对get的支持不好 . 处理方法 : 1、修改tomcat配置文件 ：设置编码！ \u003cConnector URIEncoding=\"utf-8\" port=\"8080\" protocol=\"HTTP/1.1\" connectionTimeout=\"20000\" redirectPort=\"8443\" /\u003e 2、自定义过滤器 package com.kuang.filter; import javax.servlet.*; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletRequestWrapper; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.io.UnsupportedEncodingException; import java.util.Map; /** * 解决get和post请求 全部乱码的过滤器 */ public class GenericEncodingFilter implements Filter { @Override public void destroy() { } @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { //处理response的字符编码 HttpServletResponse myResponse=(HttpServletResponse) response; myResponse.setContentType(\"text/html;charset=UTF-8\"); // 转型为与协议相关对象 HttpServletRequest httpServletRequest = (HttpServletRequest) request; // 对request包装增强 HttpServletRequest myrequest = new MyRequest(httpServletRequest); chain.doFilter(myrequest, response); } @Override public void init(FilterConfig filterConfig) throws ServletException { } } //自定义request对象，HttpServletRequest的包装类 class MyRequest extends HttpServletRequestWrapper { private HttpServletRequest request; //是否编码的标记 private boolean hasEncode; //定义一个可以传入HttpServletRequest对象的构造函数，以便对其进行装饰 public MyRequest(HttpServletRequest request) { super(request);// super必须写 this.request = request; } // 对需要增强方法 进行覆盖 @Override public Map getParameterMap() { // 先获得请求方式 String method = request.getMethod(); if (method.equalsIgnoreCase(\"post\")) { // post请求 try { // 处理post乱码 request.setCharacterEncoding(\"utf-8\"); return request.getParameterMap(); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } } else if (method.equalsIgnoreCase(\"get\")) { // get请求 Map\u003cString, String[]\u003e parameterMap = request.getParameterMap(); if (!hasEncode) { // 确保get手动编码逻辑只运行一次 for (String parameterName : parameterMap.keySet()) { String[] values = parameterMap.get(parameterName); if (values != null) { for (int i = 0; i \u003c values.length; i++) { try { // 处理get乱码 values[i] = new String(values[i] .getBytes(\"ISO-8859-1\"), \"utf-8\"); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } } } } hasEncode = true; } return parameterMap; } return super.getParameterMap(); } //取一个值 @Override public String getParameter(String name) { Map\u003cString, String[]\u003e parameterMap = getParameterMap(); String[] values = parameterMap.get(name); if (values == null) { return null; } return values[0]; // 取回参数的第一个值 } //取所有值 @Override public String[] getParameterValues(String name) { Map\u003cString, String[]\u003e parameterMap = getParameterMap(); String[] values = parameterMap.get(name); return values; } } 这个也是我在网上找的一些大神写的，一般情况下，SpringMVC默认的乱码处理就已经能够很好的解决了！ 然后在web.xml中配置这个过滤器即可！ 乱码问题，需要平时多注意，在尽可能能设置编码的地方，都设置为统一编码 UTF-8！ ","date":"2021-09-21","objectID":"/springmvc/:4:3","tags":["SpringMVC","SSM整合"],"title":"SpringMVC","uri":"/springmvc/"},{"categories":["框架"],"content":"四、Json交互处理 ","date":"2021-09-21","objectID":"/springmvc/:5:0","tags":["SpringMVC","SSM整合"],"title":"SpringMVC","uri":"/springmvc/"},{"categories":["框架"],"content":"什么是JSON？ JSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式，目前使用特别广泛。 采用完全独立于编程语言的文本格式来存储和表示数据。 简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。 在 JavaScript 语言中，一切都是对象。因此，任何JavaScript 支持的类型都可以通过 JSON 来表示，例如字符串、数字、对象、数组等。看看他的要求和语法格式： 对象表示为键值对，数据由逗号分隔 花括号保存对象 方括号保存数组 JSON 键值对是用来保存 JavaScript 对象的一种方式，和 JavaScript 对象的写法也大同小异，键/值对组合中的键名写在前面并用双引号 \"\" 包裹，使用冒号 : 分隔，然后紧接着值： {\"name\": \"QinJiang\"} {\"age\": \"3\"} {\"sex\": \"男\"} 很多人搞不清楚 JSON 和 JavaScript 对象的关系，甚至连谁是谁都不清楚。其实，可以这么理解： JSON 是 JavaScript 对象的字符串表示法，它使用文本表示一个 JS 对象的信息，本质是一个字符串。 var obj = {a: 'Hello', b: 'World'}; //这是一个对象，注意键名也是可以使用引号包裹的 var json = '{\"a\": \"Hello\", \"b\": \"World\"}'; //这是一个 JSON 字符串，本质是一个字符串 ","date":"2021-09-21","objectID":"/springmvc/:5:1","tags":["SpringMVC","SSM整合"],"title":"SpringMVC","uri":"/springmvc/"},{"categories":["框架"],"content":"JSON 和 JavaScript 对象互转 要实现从JSON字符串转换为JavaScript 对象，使用 JSON.parse() 方法： var obj = JSON.parse('{\"a\": \"Hello\", \"b\": \"World\"}'); //结果是 {a: 'Hello', b: 'World'} 要实现从JavaScript 对象转换为JSON字符串，使用 JSON.stringify() 方法： var json = JSON.stringify({a: 'Hello', b: 'World'}); //结果是 '{\"a\": \"Hello\", \"b\": \"World\"}' 代码测试 1、新建一个module ，springmvc-05-json ， 添加web的支持 2、在web目录下新建一个 json-1.html ， 编写测试内容 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003eJSON_秦疆\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cscript type=\"text/javascript\"\u003e //编写一个js的对象 var user = { name:\"秦疆\", age:3, sex:\"男\" }; //将js对象转换成json字符串 var str = JSON.stringify(user); console.log(str); //将json字符串转换为js对象 var user2 = JSON.parse(str); console.log(user2.age,user2.name,user2.sex); \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 3、在IDEA中使用浏览器打开，查看控制台输出！ Controller返回JSON数据 Jackson应该是目前比较好的json解析工具了 当然工具不止这一个，比如还有阿里巴巴的 fastjson 等等。 我们这里使用Jackson，使用它需要导入它的jar包； \u003c!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-core --\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.fasterxml.jackson.core\u003c/groupId\u003e \u003cartifactId\u003ejackson-databind\u003c/artifactId\u003e \u003cversion\u003e2.9.8\u003c/version\u003e \u003c/dependency\u003e 配置SpringMVC需要的配置 web.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cweb-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"\u003e \u003c!--1.注册servlet--\u003e \u003cservlet\u003e \u003cservlet-name\u003eSpringMVC\u003c/servlet-name\u003e \u003cservlet-class\u003eorg.springframework.web.servlet.DispatcherServlet\u003c/servlet-class\u003e \u003c!--通过初始化参数指定SpringMVC配置文件的位置，进行关联--\u003e \u003cinit-param\u003e \u003cparam-name\u003econtextConfigLocation\u003c/param-name\u003e \u003cparam-value\u003eclasspath:springmvc-servlet.xml\u003c/param-value\u003e \u003c/init-param\u003e \u003c!-- 启动顺序，数字越小，启动越早 --\u003e \u003cload-on-startup\u003e1\u003c/load-on-startup\u003e \u003c/servlet\u003e \u003c!--所有请求都会被springmvc拦截 --\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003eSpringMVC\u003c/servlet-name\u003e \u003curl-pattern\u003e/\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e \u003cfilter\u003e \u003cfilter-name\u003eencoding\u003c/filter-name\u003e \u003cfilter-class\u003eorg.springframework.web.filter.CharacterEncodingFilter\u003c/filter-class\u003e \u003cinit-param\u003e \u003cparam-name\u003eencoding\u003c/param-name\u003e \u003cparam-value\u003eutf-8\u003c/param-value\u003e \u003c/init-param\u003e \u003c/filter\u003e \u003cfilter-mapping\u003e \u003cfilter-name\u003eencoding\u003c/filter-name\u003e \u003curl-pattern\u003e/\u003c/url-pattern\u003e \u003c/filter-mapping\u003e \u003c/web-app\u003e springmvc-servlet.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\"\u003e \u003c!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --\u003e \u003ccontext:component-scan base-package=\"com.kuang.controller\"/\u003e \u003c!-- 视图解析器 --\u003e \u003cbean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" id=\"internalResourceViewResolver\"\u003e \u003c!-- 前缀 --\u003e \u003cproperty name=\"prefix\" value=\"/WEB-INF/jsp/\" /\u003e \u003c!-- 后缀 --\u003e \u003cproperty name=\"suffix\" value=\".jsp\" /\u003e \u003c/bean\u003e \u003c/beans\u003e 我们随便编写一个User的实体类，然后我们去编写我们的测试Controller； package com.kuang.pojo; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; //需要导入lombok @Data @AllArgsConstructor @NoArgsConstructor public class User { private String name; private int age; private String sex; } 这里我们需要两个新东西，一个是@ResponseBody，一个是ObjectMapper对象，我们看下具体的用法 编写一个Controller； @Controller public class UserController { @RequestMapping(\"/json1\") @ResponseBody public String json1() throws JsonProcessingException { //创建一个jackson的对象映射器，用来解析数据 ObjectMapper mapper = new ObjectMapper(); //创建一个对象 User user = new User(\"秦疆1号\", 3, \"男\"); //将我们的对象解析成为json格式 String str = mapper.writeValueAsString(user); //由于@ResponseBody注解，这里会将str转成json格式返回；十分方便 return str; } } 配置To","date":"2021-09-21","objectID":"/springmvc/:5:2","tags":["SpringMVC","SSM整合"],"title":"SpringMVC","uri":"/springmvc/"},{"categories":["框架"],"content":"代码优化 乱码统一解决 上一种方法比较麻烦，如果项目中有许多请求则每一个都要添加，可以通过Spring配置统一指定，这样就不用每次都去处理了！ 我们可以在springmvc的配置文件上添加一段消息StringHttpMessageConverter转换配置！ \u003cmvc:annotation-driven\u003e \u003cmvc:message-converters register-defaults=\"true\"\u003e \u003cbean class=\"org.springframework.http.converter.StringHttpMessageConverter\"\u003e \u003cconstructor-arg value=\"UTF-8\"/\u003e \u003c/bean\u003e \u003cbean class=\"org.springframework.http.converter.json.MappingJackson2HttpMessageConverter\"\u003e \u003cproperty name=\"objectMapper\"\u003e \u003cbean class=\"org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean\"\u003e \u003cproperty name=\"failOnEmptyBeans\" value=\"false\"/\u003e \u003c/bean\u003e \u003c/property\u003e \u003c/bean\u003e \u003c/mvc:message-converters\u003e \u003c/mvc:annotation-driven\u003e 返回json字符串统一解决 在类上直接使用 @RestController ，这样子，里面所有的方法都只会返回 json 字符串了，不用再每一个都添加@ResponseBody ！我们在前后端分离开发中，一般都使用 @RestController ，十分便捷！ @RestController public class UserController { //produces:指定响应体返回类型和编码 @RequestMapping(value = \"/json1\") public String json1() throws JsonProcessingException { //创建一个jackson的对象映射器，用来解析数据 ObjectMapper mapper = new ObjectMapper(); //创建一个对象 User user = new User(\"秦疆1号\", 3, \"男\"); //将我们的对象解析成为json格式 String str = mapper.writeValueAsString(user); //由于@ResponseBody注解，这里会将str转成json格式返回；十分方便 return str; } } 启动tomcat测试，结果都正常输出！ 测试集合输出 增加一个新的方法 @RequestMapping(\"/json2\") public String json2() throws JsonProcessingException { //创建一个jackson的对象映射器，用来解析数据 ObjectMapper mapper = new ObjectMapper(); //创建一个对象 User user1 = new User(\"秦疆1号\", 3, \"男\"); User user2 = new User(\"秦疆2号\", 3, \"男\"); User user3 = new User(\"秦疆3号\", 3, \"男\"); User user4 = new User(\"秦疆4号\", 3, \"男\"); List\u003cUser\u003e list = new ArrayList\u003cUser\u003e(); list.add(user1); list.add(user2); list.add(user3); list.add(user4); //将我们的对象解析成为json格式 String str = mapper.writeValueAsString(list); return str; } 运行结果 : 十分完美，没有任何问题！ 输出时间对象 增加一个新的方法 @RequestMapping(\"/json3\") public String json3() throws JsonProcessingException { ObjectMapper mapper = new ObjectMapper(); //创建时间一个对象，java.util.Date Date date = new Date(); //将我们的对象解析成为json格式 String str = mapper.writeValueAsString(date); return str; } 运行结果 : 默认日期格式会变成一个数字，是1970年1月1日到当前日期的毫秒数！ Jackson 默认是会把时间转成timestamps形式 解决方案：取消timestamps形式 ， 自定义时间格式 @RequestMapping(\"/json4\") public String json4() throws JsonProcessingException { ObjectMapper mapper = new ObjectMapper(); //不使用时间戳的方式 mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); //自定义日期格式对象 SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); //指定日期格式 mapper.setDateFormat(sdf); Date date = new Date(); String str = mapper.writeValueAsString(date); return str; } 运行结果 : 成功的输出了时间！ 抽取为工具类 如果要经常使用的话，这样是比较麻烦的，我们可以将这些代码封装到一个工具类中；我们去编写下 package com.kuang.utils; import com.fasterxml.jackson.core.JsonProcessingException; import com.fasterxml.jackson.databind.ObjectMapper; import com.fasterxml.jackson.databind.SerializationFeature; import java.text.SimpleDateFormat; public class JsonUtils { public static String getJson(Object object) { return getJson(object,\"yyyy-MM-dd HH:mm:ss\"); } public static String getJson(Object object,String dateFormat) { ObjectMapper mapper = new ObjectMapper(); //不使用时间差的方式 mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); //自定义日期格式对象 SimpleDateFormat sdf = new SimpleDateFormat(dateFormat); //指定日期格式 mapper.setDateFormat(sdf); try { return mapper.writeValueAsString(object); } catch (JsonProcessingException e) { e.printStackTrace(); } return null; } } 我们使用工具类，代码就更加简洁了！ @RequestMapping(\"/json5\") public String json5() throws JsonProcessingException { Date date = new Date(); String json = JsonUtils.getJson(date); return json; } 大功告成！完美！ FastJson fastjson.jar是阿里开发的一款专门用于Java开发的包，可以方便的实现json对象与JavaBean对象的转换，实现JavaBean对象与json字符串的转换，实现json对象与json字符串的转换。实现json的转换方法很多，最后的实现结果都是一样的。 fastjson 的 pom依赖！ \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba\u003c/groupId\u003e \u003cartifactId\u003efastjson\u003c/artifactId\u003e \u003cversion\u003e1.2.60\u003c/version\u003e \u003c/dependency\u003e fastjson 三个主要的类： JSONObject 代表 json 对象 JSONObject实现了Map接口, 猜想 JSONObject底层操作是由Map实现的。 JSONObject对应json对象，通过各种形式的get()方法可以获取json对象中的数据，也可利用诸如size()，isEmpty()等方法获取\"键：值\"对的","date":"2021-09-21","objectID":"/springmvc/:5:3","tags":["SpringMVC","SSM整合"],"title":"SpringMVC","uri":"/springmvc/"},{"categories":["框架"],"content":"五、整合SSM ","date":"2021-09-21","objectID":"/springmvc/:6:0","tags":["SpringMVC","SSM整合"],"title":"SpringMVC","uri":"/springmvc/"},{"categories":["框架"],"content":"环境要求 环境： IDEA MySQL 5.7.19 Tomcat 9 Maven 3.6 要求： 需要熟练掌握MySQL数据库，Spring，JavaWeb及MyBatis知识，简单的前端知识； 数据库环境 创建一个存放书籍数据的数据库表 CREATE DATABASE `ssmbuild`; USE `ssmbuild`; DROP TABLE IF EXISTS `books`; CREATE TABLE `books` ( `bookID` INT(10) NOT NULL AUTO_INCREMENT COMMENT '书id', `bookName` VARCHAR(100) NOT NULL COMMENT '书名', `bookCounts` INT(11) NOT NULL COMMENT '数量', `detail` VARCHAR(200) NOT NULL COMMENT '描述', KEY `bookID` (`bookID`) ) ENGINE=INNODB DEFAULT CHARSET=utf8 INSERT INTO `books`(`bookID`,`bookName`,`bookCounts`,`detail`)VALUES (1,'Java',1,'从入门到放弃'), (2,'MySQL',10,'从删库到跑路'), (3,'Linux',5,'从进门到进牢'); 基本环境搭建 1、新建一Maven项目！ssmbuild ， 添加web的支持 2、导入相关的pom依赖！ \u003cdependencies\u003e \u003c!--Junit--\u003e \u003cdependency\u003e \u003cgroupId\u003ejunit\u003c/groupId\u003e \u003cartifactId\u003ejunit\u003c/artifactId\u003e \u003cversion\u003e4.12\u003c/version\u003e \u003c/dependency\u003e \u003c!--数据库驱动--\u003e \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003cversion\u003e5.1.47\u003c/version\u003e \u003c/dependency\u003e \u003c!-- 数据库连接池 --\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.mchange\u003c/groupId\u003e \u003cartifactId\u003ec3p0\u003c/artifactId\u003e \u003cversion\u003e0.9.5.2\u003c/version\u003e \u003c/dependency\u003e \u003c!--Servlet - JSP --\u003e \u003cdependency\u003e \u003cgroupId\u003ejavax.servlet\u003c/groupId\u003e \u003cartifactId\u003eservlet-api\u003c/artifactId\u003e \u003cversion\u003e2.5\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ejavax.servlet.jsp\u003c/groupId\u003e \u003cartifactId\u003ejsp-api\u003c/artifactId\u003e \u003cversion\u003e2.2\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ejavax.servlet\u003c/groupId\u003e \u003cartifactId\u003ejstl\u003c/artifactId\u003e \u003cversion\u003e1.2\u003c/version\u003e \u003c/dependency\u003e \u003c!--Mybatis--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis\u003c/groupId\u003e \u003cartifactId\u003emybatis\u003c/artifactId\u003e \u003cversion\u003e3.5.2\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis\u003c/groupId\u003e \u003cartifactId\u003emybatis-spring\u003c/artifactId\u003e \u003cversion\u003e2.0.2\u003c/version\u003e \u003c/dependency\u003e \u003c!--Spring--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-webmvc\u003c/artifactId\u003e \u003cversion\u003e5.1.9.RELEASE\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-jdbc\u003c/artifactId\u003e \u003cversion\u003e5.1.9.RELEASE\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e 3、Maven资源过滤设置 \u003cbuild\u003e \u003cresources\u003e \u003cresource\u003e \u003cdirectory\u003esrc/main/java\u003c/directory\u003e \u003cincludes\u003e \u003cinclude\u003e**/*.properties\u003c/include\u003e \u003cinclude\u003e**/*.xml\u003c/include\u003e \u003c/includes\u003e \u003cfiltering\u003efalse\u003c/filtering\u003e \u003c/resource\u003e \u003cresource\u003e \u003cdirectory\u003esrc/main/resources\u003c/directory\u003e \u003cincludes\u003e \u003cinclude\u003e**/*.properties\u003c/include\u003e \u003cinclude\u003e**/*.xml\u003c/include\u003e \u003c/includes\u003e \u003cfiltering\u003efalse\u003c/filtering\u003e \u003c/resource\u003e \u003c/resources\u003e \u003c/build\u003e 4、建立基本结构和配置框架！ com.kuang.pojo com.kuang.dao com.kuang.service com.kuang.controller mybatis-config.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"\u003e \u003cconfiguration\u003e \u003c/configuration\u003e applicationContext.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u003c/beans\u003e Mybatis层编写 1、数据库配置文件 database.properties jdbc.driver=com.mysql.cj.jdbc.Driver #如果使用的是Mysql8.0+需要增加一个时区的配置 jdbc.url=jdbc:mysql://localhost:3306/ssmbuild?useSSL=true\u0026useUnicode=true\u0026characterEncoding=utf8\u0026ServerTimezone=Asia/Chongqing jdbc.username=root jdbc.password=123456 2、IDEA关联数据库 3、编写MyBatis的核心配置文件 \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"\u003e \u003cconfiguration\u003e \u003ctypeAliases\u003e \u003cpackage name=\"com.kuang.pojo\"/\u003e \u003c/typeAliases\u003e \u003cmappers\u003e \u003cmapper resource=\"com/kuang/dao/BookMapper.xml\"/\u003e \u003c/mappers\u003e \u003c/configuration\u003e 4、编写数据库对应的实体类 com.kuang.pojo.Books 使用lombok插件！ package com.kuang.pojo; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; @Data @AllArgsConstructor @NoArgsConstructor public class Books { private int bookID; private String bookName; private int bookCounts; private String detail; } 5、编写Dao层的 Mapper接口！ package com.kuang.dao; ","date":"2021-09-21","objectID":"/springmvc/:6:1","tags":["SpringMVC","SSM整合"],"title":"SpringMVC","uri":"/springmvc/"},{"categories":["框架"],"content":"六、Ajax ","date":"2021-09-21","objectID":"/springmvc/:7:0","tags":["SpringMVC","SSM整合"],"title":"SpringMVC","uri":"/springmvc/"},{"categories":["框架"],"content":"简介 AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。 AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。 Ajax 不是一种新的编程语言，而是一种用于创建更好更快以及交互性更强的Web应用程序的技术。 在 2005 年，Google 通过其 Google Suggest 使 AJAX 变得流行起来。Google Suggest能够自动帮你完成搜索单词。 Google Suggest 使用 AJAX 创造出动态性极强的 web 界面：当您在谷歌的搜索框输入关键字时，JavaScript 会把这些字符发送到服务器，然后服务器会返回一个搜索建议的列表。 就和国内百度的搜索框一样! 传统的网页(即不用ajax技术的网页)，想要更新内容或者提交一个表单，都需要重新加载整个网页。 使用ajax技术的网页，通过在后台服务器进行少量的数据交换，就可以实现异步局部更新。 使用Ajax，用户可以创建接近本地桌面应用的直接、高可用、更丰富、更动态的Web用户界面。 ","date":"2021-09-21","objectID":"/springmvc/:7:1","tags":["SpringMVC","SSM整合"],"title":"SpringMVC","uri":"/springmvc/"},{"categories":["框架"],"content":"伪造Ajax 我们可以使用前端的一个标签来伪造一个ajax的样子。iframe标签 1、新建一个module ：sspringmvc-06-ajax ， 导入web支持！ 2、编写一个 ajax-frame.html 使用 iframe 测试，感受下效果 \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead lang=\"en\"\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003ekuangshen\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cscript type=\"text/javascript\"\u003e window.onload = function(){ var myDate = new Date(); document.getElementById('currentTime').innerText = myDate.getTime(); }; function LoadPage(){ var targetUrl = document.getElementById('url').value; console.log(targetUrl); document.getElementById(\"iframePosition\").src = targetUrl; } \u003c/script\u003e \u003cdiv\u003e \u003cp\u003e请输入要加载的地址：\u003cspan id=\"currentTime\"\u003e\u003c/span\u003e\u003c/p\u003e \u003cp\u003e \u003cinput id=\"url\" type=\"text\" value=\"https://www.baidu.com/\"/\u003e \u003cinput type=\"button\" value=\"提交\" onclick=\"LoadPage()\"\u003e \u003c/p\u003e \u003c/div\u003e \u003cdiv\u003e \u003ch3\u003e加载页面位置：\u003c/h3\u003e \u003ciframe id=\"iframePosition\" style=\"width: 100%;height: 500px;\"\u003e\u003c/iframe\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e 3、使用IDEA开浏览器测试一下！ 利用AJAX可以做： 注册时，输入用户名自动检测用户是否已经存在。 登陆时，提示用户名密码错误 删除数据行时，将行ID发送到后台，后台在数据库中删除，数据库删除成功后，在页面DOM中将数据行也删除。 ….等等 ","date":"2021-09-21","objectID":"/springmvc/:7:2","tags":["SpringMVC","SSM整合"],"title":"SpringMVC","uri":"/springmvc/"},{"categories":["框架"],"content":"jQuery.ajax 纯JS原生实现Ajax我们不去讲解这里，直接使用jquery提供的，方便学习和使用，避免重复造轮子，有兴趣的同学可以去了解下JS原生XMLHttpRequest ！ Ajax的核心是XMLHttpRequest对象(XHR)。XHR为向服务器发送请求和解析服务器响应提供了接口。能够以异步方式从服务器获取新数据。 jQuery 提供多个与 AJAX 有关的方法。 通过 jQuery AJAX 方法，您能够使用 HTTP Get 和 HTTP Post 从远程服务器上请求文本、HTML、XML 或 JSON – 同时您能够把这些外部数据直接载入网页的被选元素中。 jQuery 不是生产者，而是大自然搬运工。 jQuery Ajax本质就是 XMLHttpRequest，对他进行了封装，方便调用！ jQuery.ajax(...) 部分参数： url：请求地址 type：请求方式，GET、POST（1.9.0之后用method） headers：请求头 data：要发送的数据 contentType：即将发送信息至服务器的内容编码类型(默认: \"application/x-www-form-urlencoded; charset=UTF-8\") async：是否异步 timeout：设置请求超时时间（毫秒） beforeSend：发送请求前执行的函数(全局) complete：完成之后执行的回调函数(全局) success：成功之后执行的回调函数(全局) error：失败之后执行的回调函数(全局) accepts：通过请求头发送给服务器，告诉服务器当前客户端可接受的数据类型 dataType：将服务器端返回的数据转换成指定类型 \"xml\": 将服务器端返回的内容转换成xml格式 \"text\": 将服务器端返回的内容转换成普通文本格式 \"html\": 将服务器端返回的内容转换成普通文本格式，在插入DOM中时，如果包含JavaScript标签，则会尝试去执行。 \"script\": 尝试将返回值当作JavaScript去执行，然后再将服务器端返回的内容转换成普通文本格式 \"json\": 将服务器端返回的内容转换成相应的JavaScript对象 \"jsonp\": JSONP 格式使用 JSONP 形式调用函数时，如 \"myurl?callback=?\" jQuery 将自动替换 ? 为正确的函数名，以执行回调函数 我们来个简单的测试，使用最原始的HttpServletResponse处理 , .最简单 , 最通用 1、配置web.xml 和 springmvc的配置文件，复制上面案例的即可 【记得静态资源过滤和注解驱动配置上】 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\"\u003e \u003c!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --\u003e \u003ccontext:component-scan base-package=\"com.kuang.controller\"/\u003e \u003cmvc:default-servlet-handler /\u003e \u003cmvc:annotation-driven /\u003e \u003c!-- 视图解析器 --\u003e \u003cbean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" id=\"internalResourceViewResolver\"\u003e \u003c!-- 前缀 --\u003e \u003cproperty name=\"prefix\" value=\"/WEB-INF/jsp/\" /\u003e \u003c!-- 后缀 --\u003e \u003cproperty name=\"suffix\" value=\".jsp\" /\u003e \u003c/bean\u003e \u003c/beans\u003e 2、编写一个AjaxController @Controller public class AjaxController { @RequestMapping(\"/a1\") public void ajax1(String name , HttpServletResponse response) throws IOException { if (\"admin\".equals(name)){ response.getWriter().print(\"true\"); }else{ response.getWriter().print(\"false\"); } } } 3、导入jquery ， 可以使用在线的CDN ， 也可以下载导入 \u003cscript src=\"https://code.jquery.com/jquery-3.1.1.min.js\"\u003e\u003c/script\u003e \u003cscript src=\"${pageContext.request.contextPath}/statics/js/jquery-3.1.1.min.js\"\u003e\u003c/script\u003e 4、编写index.jsp测试 \u003c%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %\u003e \u003chtml\u003e \u003chead\u003e \u003ctitle\u003e$Title$\u003c/title\u003e \u003c%--\u003cscript src=\"https://code.jquery.com/jquery-3.1.1.min.js\"\u003e\u003c/script\u003e--%\u003e \u003cscript src=\"${pageContext.request.contextPath}/statics/js/jquery-3.1.1.min.js\"\u003e\u003c/script\u003e \u003cscript\u003e function a1(){ $.post({ url:\"${pageContext.request.contextPath}/a1\", data:{'name':$(\"#txtName\").val()}, success:function (data,status) { alert(data); alert(status); } }); } \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003c%--onblur：失去焦点触发事件--%\u003e 用户名:\u003cinput type=\"text\" id=\"txtName\" onblur=\"a1()\"/\u003e \u003c/body\u003e \u003c/html\u003e 5、启动tomcat测试！打开浏览器的控制台，当我们鼠标离开输入框的时候，可以看到发出了一个ajax的请求！是后台返回给我们的结果！测试成功！ Springmvc实现 实体类user @Data @AllArgsConstructor @NoArgsConstructor public class User { private String name; private int age; private String sex; } 我们来获取一个集合对象，展示到前端页面 @RequestMapping(\"/a2\") public List\u003cUser\u003e ajax2(){ List\u003cUser\u003e list = new ArrayList\u003cUser\u003e(); list.add(new User(\"秦疆1号\",3,\"男\")); list.add(new User(\"秦疆2号\",3,\"男\")); list.add(new User(\"秦疆3号\",3,\"男\")); return list; //由于@RestController注解，将list转成json格式返回 } 前端页面 \u003c%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %\u003e \u003chtml\u003e \u003chead\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cinput type=\"button\" id=\"btn\" value=\"获取数据\"/\u003e \u003ctable width=\"80%\" align=\"center\"\u003e \u003ctr\u003e \u003ctd\u003e姓名\u003c/td\u003e \u003ctd\u003e年龄\u003c/td\u003e \u003ctd\u003e性别\u003c/td\u003e \u003c/tr\u003e \u003ctbody id=\"content\"\u003e \u003c/tbody\u003e \u003c/table\u003e \u003cscript src","date":"2021-09-21","objectID":"/springmvc/:7:3","tags":["SpringMVC","SSM整合"],"title":"SpringMVC","uri":"/springmvc/"},{"categories":["框架"],"content":"七、拦截器 ","date":"2021-09-21","objectID":"/springmvc/:8:0","tags":["SpringMVC","SSM整合"],"title":"SpringMVC","uri":"/springmvc/"},{"categories":["框架"],"content":"概述 SpringMVC的处理器拦截器类似于Servlet开发中的过滤器Filter,用于对处理器进行预处理和后处理。开发者可以自己定义一些拦截器来实现特定的功能。 **过滤器与拦截器的区别：**拦截器是AOP思想的具体应用。 过滤器 servlet规范中的一部分，任何java web工程都可以使用 在url-pattern中配置了/*之后，可以对所有要访问的资源进行拦截 拦截器 拦截器是SpringMVC框架自己的，只有使用了SpringMVC框架的工程才能使用 拦截器只会拦截访问的控制器方法， 如果访问的是jsp/html/css/image/js是不会进行拦截的 ","date":"2021-09-21","objectID":"/springmvc/:8:1","tags":["SpringMVC","SSM整合"],"title":"SpringMVC","uri":"/springmvc/"},{"categories":["框架"],"content":"自定义拦截器 那如何实现拦截器呢？ 想要自定义拦截器，必须实现 HandlerInterceptor 接口。 1、新建一个Moudule ， springmvc-07-Interceptor ， 添加web支持 2、配置web.xml 和 springmvc-servlet.xml 文件 3、编写一个拦截器 package com.kuang.interceptor; import org.springframework.web.servlet.HandlerInterceptor; import org.springframework.web.servlet.ModelAndView; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; public class MyInterceptor implements HandlerInterceptor { //在请求处理的方法之前执行 //如果返回true执行下一个拦截器 //如果返回false就不执行下一个拦截器 public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception { System.out.println(\"------------处理前------------\"); return true; } //在请求处理方法执行之后执行 public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception { System.out.println(\"------------处理后------------\"); } //在dispatcherServlet处理后执行,做清理工作. public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception { System.out.println(\"------------清理------------\"); } } 4、在springmvc的配置文件中配置拦截器 \u003c!--关于拦截器的配置--\u003e \u003cmvc:interceptors\u003e \u003cmvc:interceptor\u003e \u003c!--/** 包括路径及其子路径--\u003e \u003c!--/admin/* 拦截的是/admin/add等等这种 , /admin/add/user不会被拦截--\u003e \u003c!--/admin/** 拦截的是/admin/下的所有--\u003e \u003cmvc:mapping path=\"/**\"/\u003e \u003c!--bean配置的就是拦截器--\u003e \u003cbean class=\"com.kuang.interceptor.MyInterceptor\"/\u003e \u003c/mvc:interceptor\u003e \u003c/mvc:interceptors\u003e 5、编写一个Controller，接收请求 package com.kuang.controller; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.ResponseBody; //测试拦截器的控制器 @Controller public class InterceptorController { @RequestMapping(\"/interceptor\") @ResponseBody public String testFunction() { System.out.println(\"控制器中的方法执行了\"); return \"hello\"; } } 6、前端 index.jsp \u003ca href=\"${pageContext.request.contextPath}/interceptor\"\u003e拦截器测试\u003c/a\u003e 7、启动tomcat 测试一下！ ","date":"2021-09-21","objectID":"/springmvc/:8:2","tags":["SpringMVC","SSM整合"],"title":"SpringMVC","uri":"/springmvc/"},{"categories":["框架"],"content":"验证用户是否登录 (认证用户) 实现思路 1、有一个登陆页面，需要写一个controller访问页面。 2、登陆页面有一提交表单的动作。需要在controller中处理。判断用户名密码是否正确。如果正确，向session中写入用户信息。返回登陆成功。 3、拦截用户请求，判断用户是否登陆。如果用户已经登陆。放行， 如果用户未登陆，跳转到登陆页面 测试： 1、编写一个登陆页面 login.jsp \u003c%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %\u003e \u003chtml\u003e \u003chead\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003c/head\u003e \u003ch1\u003e登录页面\u003c/h1\u003e \u003chr\u003e \u003cbody\u003e \u003cform action=\"${pageContext.request.contextPath}/user/login\"\u003e 用户名：\u003cinput type=\"text\" name=\"username\"\u003e \u003cbr\u003e 密码：\u003cinput type=\"password\" name=\"pwd\"\u003e \u003cbr\u003e \u003cinput type=\"submit\" value=\"提交\"\u003e \u003c/form\u003e \u003c/body\u003e \u003c/html\u003e 2、编写一个Controller处理请求 package com.kuang.controller; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import javax.servlet.http.HttpSession; @Controller @RequestMapping(\"/user\") public class UserController { //跳转到登陆页面 @RequestMapping(\"/jumplogin\") public String jumpLogin() throws Exception { return \"login\"; } //跳转到成功页面 @RequestMapping(\"/jumpSuccess\") public String jumpSuccess() throws Exception { return \"success\"; } //登陆提交 @RequestMapping(\"/login\") public String login(HttpSession session, String username, String pwd) throws Exception { // 向session记录用户身份信息 System.out.println(\"接收前端===\"+username); session.setAttribute(\"user\", username); return \"success\"; } //退出登陆 @RequestMapping(\"logout\") public String logout(HttpSession session) throws Exception { // session 过期 session.invalidate(); return \"login\"; } } 3、编写一个登陆成功的页面 success.jsp \u003c%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %\u003e \u003chtml\u003e \u003chead\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003e登录成功页面\u003c/h1\u003e \u003chr\u003e ${user} \u003ca href=\"${pageContext.request.contextPath}/user/logout\"\u003e注销\u003c/a\u003e \u003c/body\u003e \u003c/html\u003e 4、在 index 页面上测试跳转！启动Tomcat 测试，未登录也可以进入主页！ \u003c%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %\u003e \u003chtml\u003e \u003chead\u003e \u003ctitle\u003e$Title$\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003e首页\u003c/h1\u003e \u003chr\u003e \u003c%--登录--%\u003e \u003ca href=\"${pageContext.request.contextPath}/user/jumplogin\"\u003e登录\u003c/a\u003e \u003ca href=\"${pageContext.request.contextPath}/user/jumpSuccess\"\u003e成功页面\u003c/a\u003e \u003c/body\u003e \u003c/html\u003e 5、编写用户登录拦截器 package com.kuang.interceptor; import org.springframework.web.servlet.HandlerInterceptor; import org.springframework.web.servlet.ModelAndView; import javax.servlet.ServletException; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import javax.servlet.http.HttpSession; import java.io.IOException; public class LoginInterceptor implements HandlerInterceptor { public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws ServletException, IOException { // 如果是登陆页面则放行 System.out.println(\"uri: \" + request.getRequestURI()); if (request.getRequestURI().contains(\"login\")) { return true; } HttpSession session = request.getSession(); // 如果用户已登陆也放行 if(session.getAttribute(\"user\") != null) { return true; } // 用户没有登陆跳转到登陆页面 request.getRequestDispatcher(\"/WEB-INF/jsp/login.jsp\").forward(request, response); return false; } public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception { } public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception { } } 6、在Springmvc的配置文件中注册拦截器 \u003c!--关于拦截器的配置--\u003e \u003cmvc:interceptors\u003e \u003cmvc:interceptor\u003e \u003cmvc:mapping path=\"/**\"/\u003e \u003cbean id=\"loginInterceptor\" class=\"com.kuang.interceptor.LoginInterceptor\"/\u003e \u003c/mvc:interceptor\u003e \u003c/mvc:interceptors\u003e 7、再次重启Tomcat测试！ OK，测试登录拦截功能无误. ","date":"2021-09-21","objectID":"/springmvc/:8:3","tags":["SpringMVC","SSM整合"],"title":"SpringMVC","uri":"/springmvc/"},{"categories":["框架"],"content":"八、文件上传和下载 ","date":"2021-09-21","objectID":"/springmvc/:9:0","tags":["SpringMVC","SSM整合"],"title":"SpringMVC","uri":"/springmvc/"},{"categories":["框架"],"content":"准备工作 文件上传是项目开发中最常见的功能之一 ,springMVC 可以很好的支持文件上传，但是SpringMVC上下文中默认没有装配MultipartResolver，因此默认情况下其不能处理文件上传工作。如果想使用Spring的文件上传功能，则需要在上下文中配置MultipartResolver。 前端表单要求：为了能上传文件，必须将表单的method设置为POST，并将enctype设置为multipart/form-data。只有在这样的情况下，浏览器才会把用户选择的文件以二进制数据发送给服务器； 对表单中的 enctype 属性做个详细的说明： application/x-www=form-urlencoded：默认方式，只处理表单域中的 value 属性值，采用这种编码方式的表单会将表单域中的值处理成 URL 编码方式。 multipart/form-data：这种编码方式会以二进制流的方式来处理表单数据，这种编码方式会把文件域指定文件的内容也封装到请求参数中，不会对字符编码。 text/plain：除了把空格转换为 “+” 号外，其他字符都不做编码处理，这种方式适用直接通过表单发送邮件。 \u003cform action=\"\" enctype=\"multipart/form-data\" method=\"post\"\u003e \u003cinput type=\"file\" name=\"file\"/\u003e \u003cinput type=\"submit\"\u003e \u003c/form\u003e 一旦设置了enctype为multipart/form-data，浏览器即会采用二进制流的方式来处理表单数据，而对于文件上传的处理则涉及在服务器端解析原始的HTTP响应。在2003年，Apache Software Foundation发布了开源的Commons FileUpload组件，其很快成为Servlet/JSP程序员上传文件的最佳选择。 Servlet3.0规范已经提供方法来处理文件上传，但这种上传需要在Servlet中完成。 而Spring MVC则提供了更简单的封装。 Spring MVC为文件上传提供了直接的支持，这种支持是用即插即用的MultipartResolver实现的。 Spring MVC使用Apache Commons FileUpload技术实现了一个MultipartResolver实现类： CommonsMultipartResolver。因此，SpringMVC的文件上传还需要依赖Apache Commons FileUpload的组件。 ","date":"2021-09-21","objectID":"/springmvc/:9:1","tags":["SpringMVC","SSM整合"],"title":"SpringMVC","uri":"/springmvc/"},{"categories":["框架"],"content":"文件上传 1、导入文件上传的jar包，commons-fileupload ， Maven会自动帮我们导入他的依赖包 commons-io包； \u003c!--文件上传--\u003e \u003cdependency\u003e \u003cgroupId\u003ecommons-fileupload\u003c/groupId\u003e \u003cartifactId\u003ecommons-fileupload\u003c/artifactId\u003e \u003cversion\u003e1.3.3\u003c/version\u003e \u003c/dependency\u003e \u003c!--servlet-api导入高版本的--\u003e \u003cdependency\u003e \u003cgroupId\u003ejavax.servlet\u003c/groupId\u003e \u003cartifactId\u003ejavax.servlet-api\u003c/artifactId\u003e \u003cversion\u003e4.0.1\u003c/version\u003e \u003c/dependency\u003e 2、配置bean：multipartResolver 【注意！！！这个bena的id必须为：multipartResolver ， 否则上传文件会报400的错误！在这里栽过坑,教训！】 \u003c!--文件上传配置--\u003e \u003cbean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"\u003e \u003c!-- 请求的编码格式，必须和jSP的pageEncoding属性一致，以便正确读取表单的内容，默认为ISO-8859-1 --\u003e \u003cproperty name=\"defaultEncoding\" value=\"utf-8\"/\u003e \u003c!-- 上传文件大小上限，单位为字节（10485760=10M） --\u003e \u003cproperty name=\"maxUploadSize\" value=\"10485760\"/\u003e \u003cproperty name=\"maxInMemorySize\" value=\"40960\"/\u003e \u003c/bean\u003e CommonsMultipartFile 的 常用方法： String getOriginalFilename()：获取上传文件的原名 InputStream getInputStream()：获取文件流 void transferTo(File dest)：将上传文件保存到一个目录文件中 我们去实际测试一下 3、编写前端页面 \u003cform action=\"/upload\" enctype=\"multipart/form-data\" method=\"post\"\u003e \u003cinput type=\"file\" name=\"file\"/\u003e \u003cinput type=\"submit\" value=\"upload\"\u003e \u003c/form\u003e 4、Controller package com.kuang.controller; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.multipart.commons.CommonsMultipartFile; import javax.servlet.http.HttpServletRequest; import java.io.*; @Controller public class FileController { //@RequestParam(\"file\") 将name=file控件得到的文件封装成CommonsMultipartFile 对象 //批量上传CommonsMultipartFile则为数组即可 @RequestMapping(\"/upload\") public String fileUpload(@RequestParam(\"file\") CommonsMultipartFile file , HttpServletRequest request) throws IOException { //获取文件名 : file.getOriginalFilename(); String uploadFileName = file.getOriginalFilename(); //如果文件名为空，直接回到首页！ if (\"\".equals(uploadFileName)){ return \"redirect:/index.jsp\"; } System.out.println(\"上传文件名 : \"+uploadFileName); //上传路径保存设置 String path = request.getServletContext().getRealPath(\"/upload\"); //如果路径不存在，创建一个 File realPath = new File(path); if (!realPath.exists()){ realPath.mkdir(); } System.out.println(\"上传文件保存地址：\"+realPath); InputStream is = file.getInputStream(); //文件输入流 OutputStream os = new FileOutputStream(new File(realPath,uploadFileName)); //文件输出流 //读取写出 int len=0; byte[] buffer = new byte[1024]; while ((len=is.read(buffer))!=-1){ os.write(buffer,0,len); os.flush(); } os.close(); is.close(); return \"redirect:/index.jsp\"; } } 5、测试上传文件，OK！ 采用file.Transto 来保存上传的文件 1、编写Controller /* * 采用file.Transto 来保存上传的文件 */ @RequestMapping(\"/upload2\") public String fileUpload2(@RequestParam(\"file\") CommonsMultipartFile file, HttpServletRequest request) throws IOException { //上传路径保存设置 String path = request.getServletContext().getRealPath(\"/upload\"); File realPath = new File(path); if (!realPath.exists()){ realPath.mkdir(); } //上传文件地址 System.out.println(\"上传文件保存地址：\"+realPath); //通过CommonsMultipartFile的方法直接写文件（注意这个时候） file.transferTo(new File(realPath +\"/\"+ file.getOriginalFilename())); return \"redirect:/index.jsp\"; } 2、前端表单提交地址修改 3、访问提交测试，OK！ ","date":"2021-09-21","objectID":"/springmvc/:9:2","tags":["SpringMVC","SSM整合"],"title":"SpringMVC","uri":"/springmvc/"},{"categories":["框架"],"content":"文件下载 文件下载步骤： 1、设置 response 响应头 2、读取文件 – InputStream 3、写出文件 – OutputStream 4、执行操作 5、关闭流 （先开后关） 代码实现： @RequestMapping(value=\"/download\") public String downloads(HttpServletResponse response ,HttpServletRequest request) throws Exception{ //要下载的图片地址 String path = request.getServletContext().getRealPath(\"/upload\"); String fileName = \"基础语法.jpg\"; //1、设置response 响应头 response.reset(); //设置页面不缓存,清空buffer response.setCharacterEncoding(\"UTF-8\"); //字符编码 response.setContentType(\"multipart/form-data\"); //二进制传输数据 //设置响应头 response.setHeader(\"Content-Disposition\", \"attachment;fileName=\"+URLEncoder.encode(fileName, \"UTF-8\")); File file = new File(path,fileName); //2、 读取文件--输入流 InputStream input=new FileInputStream(file); //3、 写出文件--输出流 OutputStream out = response.getOutputStream(); byte[] buff =new byte[1024]; int index=0; //4、执行 写出操作 while((index= input.read(buff))!= -1){ out.write(buff, 0, index); out.flush(); } out.close(); input.close(); return null; } 前端 \u003ca href=\"/download\"\u003e点击下载\u003c/a\u003e 测试，文件下载OK，大家可以和我们之前学习的JavaWeb原生的方式对比一下，就可以知道这个便捷多了! ","date":"2021-09-21","objectID":"/springmvc/:9:3","tags":["SpringMVC","SSM整合"],"title":"SpringMVC","uri":"/springmvc/"},{"categories":["框架"],"content":"Mybatis ","date":"2021-09-21","objectID":"/mybatis/:1:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"1、第一个Mybatis程序 ","date":"2021-09-21","objectID":"/mybatis/:2:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"导入maven依赖 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003c!-- 父工程 --\u003e \u003cgroupId\u003ecn.miaobuyi\u003c/groupId\u003e \u003cartifactId\u003essm\u003c/artifactId\u003e \u003cpackaging\u003epom\u003c/packaging\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003cmodules\u003e \u003cmodule\u003emybatis\u003c/module\u003e \u003c/modules\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-context\u003c/artifactId\u003e \u003cversion\u003e5.3.8\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis\u003c/groupId\u003e \u003cartifactId\u003emybatis\u003c/artifactId\u003e \u003cversion\u003e3.5.7\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003cversion\u003e5.1.47\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ejunit\u003c/groupId\u003e \u003cartifactId\u003ejunit\u003c/artifactId\u003e \u003cversion\u003e4.13\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003cproperties\u003e \u003cmaven.compiler.source\u003e11\u003c/maven.compiler.source\u003e \u003cmaven.compiler.target\u003e11\u003c/maven.compiler.target\u003e \u003c/properties\u003e \u003c/project\u003e ","date":"2021-09-21","objectID":"/mybatis/:2:1","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"便携mybatis的核心配置文件 \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"\u003e \u003cconfiguration\u003e \u003cenvironments default=\"development\"\u003e \u003cenvironment id=\"development\"\u003e \u003ctransactionManager type=\"JDBC\"/\u003e \u003cdataSource type=\"POOLED\"\u003e \u003cproperty name=\"driver\" value=\"com.mysql.jdbc.Driver\"/\u003e \u003cproperty name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis?useSSL=true\u0026amp;useUnicode=true\u0026amp;characterEncoding=UTF-8\"/\u003e \u003cproperty name=\"username\" value=\"root\"/\u003e \u003cproperty name=\"password\" value=\"123456\"/\u003e \u003c/dataSource\u003e \u003c/environment\u003e \u003c/environments\u003e \u003c!-- 每一个Mapper.XML都需要在Mybatis核心配置文件中注册！ --\u003e \u003cmappers\u003e \u003cmapper resource=\"com/miaobuyi/mapper/UserMapper.xml\"/\u003e \u003c/mappers\u003e \u003c/configuration\u003e ","date":"2021-09-21","objectID":"/mybatis/:2:2","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"编写mybatis工具类 package com.miaobuyi.utils; import org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import java.io.IOException; import java.io.InputStream; //sqlSessionFactory --\u003e sqlSession public class MybatisUtils { private static SqlSessionFactory sqlSessionFactory; static { try { //使用Mybatis第一步：获取sqlSessionFactory对象 String resource = \"mybatis-config.xml\"; InputStream inputStream = null; inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); } catch (IOException e) { e.printStackTrace(); } } //既然有了 ，顾名思义，我们就可以从中获得SqlSession的实例了。 //SqlSession 完全包含了面向数据库执行SQL命令所需的所有方法 public static SqlSession getSqlSeesion(){ return sqlSessionFactory.openSession(); } } ","date":"2021-09-21","objectID":"/mybatis/:2:3","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"实体类 package com.miaobuyi.pojo; public class User { private int id; private String name; private String pwd; public User(int id, String name, String pwd) { this.id = id; this.name = name; this.pwd = pwd; } public User() { } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getPwd() { return pwd; } public void setPwd(String pwd) { this.pwd = pwd; } } ","date":"2021-09-21","objectID":"/mybatis/:2:4","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"Mapper 接口 package com.miaobuyi.mapper; import com.miaobuyi.pojo.User; import java.util.List; public interface UserMapper { List\u003cUser\u003e getUserList(); } ","date":"2021-09-21","objectID":"/mybatis/:2:5","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"XML文件里不要写中文注释要报错 接口实现类 由原来的UserMapperImpl转变成为一个Mapper配置文件 \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"\u003e \u003c!--namespace=绑定一个对应的Dao/Mappser接口--\u003e \u003cmapper namespace=\"com.miaobuyi.mapper.UserMapper\"\u003e \u003c!--selecte查询语句--\u003e \u003cselect id=\"getUserList\" resultType=\"com.miaobuyi.pojo.User\"\u003e select * from mybatis.user \u003c/select\u003e \u003c/mapper\u003e ","date":"2021-09-21","objectID":"/mybatis/:2:6","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"maven maven由于他的约定大于配置，我们之后可能遇到我们配置文件，无法被到处或者生效的问题；解决方案pom.xml \u003c!-- 在build中配置resource。来防止我们资源导出失败的问题 --\u003e \u003cbuild\u003e \u003cresources\u003e \u003cresource\u003e \u003cdirectory\u003esrc/main/resource\u003c/directory\u003e \u003cincludes\u003e \u003cinclude\u003e**/*.properties\u003c/include\u003e \u003cinclude\u003e**/*.xml\u003c/include\u003e \u003c/includes\u003e \u003cfiltering\u003etrue\u003c/filtering\u003e \u003c/resource\u003e \u003cresource\u003e \u003cdirectory\u003esrc/main/java\u003c/directory\u003e \u003cincludes\u003e \u003cinclude\u003e**/*.properties\u003c/include\u003e \u003cinclude\u003e**/*.xml\u003c/include\u003e \u003c/includes\u003e \u003cfiltering\u003etrue\u003c/filtering\u003e \u003c/resource\u003e \u003c/resources\u003e \u003c/build\u003e ","date":"2021-09-21","objectID":"/mybatis/:2:7","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"测试 package com.miaobuyi.mapper; import com.miaobuyi.pojo.User; import com.miaobuyi.utils.MybatisUtils; import org.apache.ibatis.session.SqlSession; import org.junit.Test; import java.util.List; public class UserMapperTest { @Test public void test(){ //第一步获取SqlSession对象 SqlSession sqlSession = MybatisUtils.getSqlSession(); //执行sql 方式1：getMapper UserMapper userMapper = sqlSession.getMapper(UserMapper.class); List\u003cUser\u003e userList = userMapper.getUserList(); //方式2 老方式 //userList = sqlSession.selectList(\"com.miaobuyi.mapper.UserMapper.getUserList\"); for (User user :userList){ System.out.println(user); } //关闭SqlSession sqlSession.close(); } } ","date":"2021-09-21","objectID":"/mybatis/:2:8","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"2、CRUD ","date":"2021-09-21","objectID":"/mybatis/:3:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"1、namesapce namespace中的包名要和Dao/mapper接口中的包名一致！ ","date":"2021-09-21","objectID":"/mybatis/:3:1","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"2、select 选择，查询一句： id：就是对应namespace中的方法名 resultType：sql语句执行的返回值 parameterTpey：参数类型 编写接口 //根据ID查询用户 User getUserById(int id); 编写对应mapper中的sql语句 \u003cselect id=\"getUserById\" resultType=\"com.miaobuyi.pojo.User\" parameterType=\"int\"\u003e select * from mybatis.user where id = #{id} \u003c/select\u003e 测试 @Test public void getUserById(){ SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); User user = mapper.getUserById(1); System.out.println(user); sqlSession.close(); } ","date":"2021-09-21","objectID":"/mybatis/:3:2","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"3、insert \u003cinsert id=\"addUser\" parameterType=\"com.miaobuyi.pojo.User\"\u003e insert into mybatis.user (id,name,pwd)values (#{id},#{name},#{pwd}) \u003c/insert\u003e ","date":"2021-09-21","objectID":"/mybatis/:3:3","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"4、update \u003cupdate id=\"updateUser\" parameterType=\"com.miaobuyi.pojo.User\"\u003e update mybatis.user set name = #{name},pwd=#{pwd} where id=#{id}; \u003c/update\u003e ","date":"2021-09-21","objectID":"/mybatis/:3:4","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"5、delete \u003cdelete id=\"deleteUser\" parameterType=\"int\"\u003e delete from mybatis.user where id=#{id} \u003c/delete\u003e 注意：增删改需要提交事务 sqlSessionFactory.openSession(true);//工具类中 自动开启提交事务 sqlSession.commit(); ","date":"2021-09-21","objectID":"/mybatis/:3:5","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"6、分析错误 标签不要匹配错误 resource绑定mapper，需要使用路径 程序配置文件必须符合规范 NullPointerException，没有注册到资源 输出的xml文件中存在中文乱码问题（最好不要写注释） maven资源没有导出问题 ","date":"2021-09-21","objectID":"/mybatis/:3:6","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"7、万能map 假设，我们的实体类，或者数据库中的表，字段或者参数过多，我们应当考虑使用map！ //万能map User addUser2(Map\u003cString,Object\u003e map); \u003cinsert id=\"addUser2\" parameterType=\"map\"\u003e insert into mybatis.user (id,name,pwd)values (#{userid},#{uerName},#{password}) \u003c/insert\u003e @Test public void addUser2(){ SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); Map\u003cString,Object\u003e map = new HashMap\u003cString, Object\u003e(); map.put(\"userid\",\"2\"); map.put(\"userName\",\"2\"); map.put(\"password\",\"2\"); mapper.addUser2(map); sqlSession.close(); } Map传递参数时，在sql中直接取出key即可 对象传递参数，直接在sql中取对象属性即可 只有一个基本类型参数的情况下，可以直接在sql中取到 多个参数用Map，或者注解 ","date":"2021-09-21","objectID":"/mybatis/:3:7","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"8、思考题 模糊查询怎么写？ java代码执行的时候，传递通配符% % List\u003cUser\u003e userList = mapper.getUserLike(\"%李%\"); 在sql拼接中使用通配符！ select * from mybatis.user where name like \"%\"#{value}\"%\" ","date":"2021-09-21","objectID":"/mybatis/:3:8","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"3、配置解析 ","date":"2021-09-21","objectID":"/mybatis/:4:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"1、核心配置文件 mybatis-config.xml Mybatis的配置文件包含了会深深影响Mybatis行为的设置和属性信息 configuration（配置） properties（属性） settings（设置） typeAliases（类型别名） typeHandlers（类型处理器） objectFactory（对象工厂） plugins（插件） environments（环境配置） environment（环境变量） transactionManager（事务管理器） dataSource（数据源） databaseIdProvider（数据库厂商标识） mappers（映射器） ","date":"2021-09-21","objectID":"/mybatis/:4:1","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"2、环境配置（environments） MyBatis 可以配置成适应多种环境 不过要记住：尽管可以配置多个环境，但每个 SqlSessionFactory 实例只能选择一种环境。 学会使用多套配置运行环境 mybatis默认的食物管理器就是JDBC，连接池：POOLED ","date":"2021-09-21","objectID":"/mybatis/:4:2","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"3、属性（properties） 我们可以通过properties属性来实现引用配置文件 这些属性可以在外部进行配置，并可以进行动态替换。你既可以在典型的 Java 属性文件中配置这些属性，也可以在 properties 元素的子元素中设置。 db.properties 编写一个配置文件 driver=com.mysql.jdbc.Driver url=jdbc:mysql://localhost:3306/mybatis?useSSL=false\u0026amp;useUnicode=true\u0026amp;characterEncoding=UTF-8 username=root password=123456 在核心配置文件中引用 \u003cproperties resource=\"db.properties\"/\u003e 可以直接引入外部文件 可以在其中增加一些配置属性 如果两个文件有同一个字段，先读取properties元素体内指定的属性，然后根据properties元素中resource属性读取类路径下属性文件，或根据url属性指定的路径读取属性文件，并覆盖之前读取过得同名属性，最后读取作为方法参数传递的属性，并覆盖之前读取过的同名属性 ","date":"2021-09-21","objectID":"/mybatis/:4:3","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"4、类型别名(typeAliases) 类型别名是java类型设置一个短的名字 它仅用于 XML 配置，意在降低冗余的全限定类名书写 \u003ctypeAliases\u003e \u003ctypeAlias type=\"com.miaobuyi.pojo.User\" alias=\"User\"/\u003e \u003c/typeAliases\u003e 也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean 扫描实体类的包，它的默认别名就为这个类的类名，首字母小写！ \u003ctypeAliases\u003e \u003cpackage name=\"com.miaobuyi.pojo\"/\u003e \u003c/typeAliases\u003e 在实体类比较少的时候使用第一种方式 如果实体类十分多，建议使用第二种 第一种可以DIY别名，第二种不行，如果非要改，需要在实体上增加注解 @Alias(\"user\") public class User {} ","date":"2021-09-21","objectID":"/mybatis/:4:4","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"5、设置 这是MyBatis中极为重要的调整设置，它们会改变MyBatis的运行时行为。 6、其他设置 typeHandlers（类型处理器） objectFactory（对象工厂） plugins（插件） mybatis-generator-core mybatis-plus 通用mapper ","date":"2021-09-21","objectID":"/mybatis/:4:5","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"7、映射器（mappers） MapperRegistry：注册绑定我们的Mapper文件； 方式一：【推荐使用】 \u003c!-- 每一个Mapper.XML都需要在Mybatis核心配置文件中注册！ --\u003e \u003cmappers\u003e \u003cmapper resource=\"com/miaobuyi/mapper/UserMapper.xml\"/\u003e \u003cmapper class=\"com.miaobuyi.mapper.UserMapper\"/\u003e \u003c/mappers\u003e 方式二：使用class文件绑定注册 \u003cmappers\u003e \u003cmapper class=\"com.miaobuyi.mapper.UserMapper\"/\u003e \u003c/mappers\u003e 注意点： 接口和他的Mapper配置文件必须同名！ 接口和他的Mapper配置文件必须在同一个包下！ 方式三： \u003cmappers\u003e \u003cpackage name=\"com.miaobuyi.mapper\"/\u003e \u003c/mappers\u003e 接口和他的Mapper配置文件必须同名！（UserMapper接口和UserMapper.xml） 接口和他的Mapper配置文件必须在同一个包下！ ","date":"2021-09-21","objectID":"/mybatis/:4:6","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"8、生命周期和作用域 作用域和生命周期是至关重要的，因为错误的使用会导致非常严重的并发问题。 SqlSessionFactoryBuilder： 一旦创建了 SqlSessionFactory，就不再需要它了 局部变量 SqlSessionFactory： 说白了就是可以想象为：数据链接池 SqlSessionFactory一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例 因此 SqlSessionFactory 的最佳作用域是应用作用域。 有很多方法可以做到，最简单的就是使用单例模式或者静态单例模式 SqlSession 链接到连接池的一个请求！ SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域 用完之后需要赶紧关闭，否则资源被占用！ 这里面的每一个Mapper，就代表一个具体的业务！ ","date":"2021-09-21","objectID":"/mybatis/:4:7","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"4、解决属性名和字段名不一致的问题 ","date":"2021-09-21","objectID":"/mybatis/:5:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"1、问题 数据库中的字段 新建一个项目，拷贝之前的，测试实体类字段不一致的情况 public class User { private int id; private String name; private String password; } 测试出现问题 解决办法 起别名 //select * from mybatis.user where id = #{id} //类型处理器 //select id,name,pwd from mybatis.user where id = #{id}``` ","date":"2021-09-21","objectID":"/mybatis/:5:1","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"2、resultMap 结果集映射 id name pwd id name password \u003c!--结果集映射--\u003e \u003cresultMap id=\"UserMap\" type=\"user\"\u003e \u003c!--column数据库中的字段，property实体类中的属性--\u003e \u003cresult column=\"id\" property=\"id\"\u003e\u003c/result\u003e \u003cresult column=\"name\" property=\"name\"\u003e\u003c/result\u003e \u003cresult column=\"pwd\" property=\"password\"\u003e\u003c/result\u003e \u003c/resultMap\u003e \u003cselect id=\"getUserById\" resultMap=\"UserMap\"\u003e select * from mybatis.user where id = #{id} \u003c/select\u003e resultMap 元素是 MyBatis 中最重要最强大的元素 ResultMap 的设计思想是，对简单的语句做到零配置，对于复杂一点的语句，只需要描述语句之间的关系就行了。 ResultMap的优秀之处,虽然你已经对他相当了解了，但是根本就不需要显式地配置它们。 ","date":"2021-09-21","objectID":"/mybatis/:5:2","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"5、日志 ","date":"2021-09-21","objectID":"/mybatis/:6:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"1、日志工程 如果一个数据库操作，出现了异常，我们需要配错，日志就是最好的助手 曾经：sout，debug 现在：日志工厂！ SLF4J LOG4J 【掌握】 LOG4J2 JDK_LOGGING COMMONS_LOGGING STDOUT_LOGGING 【掌握】 NO_LOGGING 在mybatis中具体使用哪一个日志实现，在设置中设定 STDOUT_LOGGING标准日志输出 \u003csettings\u003e \u003csetting name=\"logImpl\" value=\"STDOUT_LOGGING\"/\u003e \u003c/settings\u003e ","date":"2021-09-21","objectID":"/mybatis/:6:1","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"2、LOG4J 什么是LOG4J ？ Log4j是Apache的一个开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件 通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。 通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。 先导入LOG4J 的包、 \u003c!-- https://mvnrepository.com/artifact/log4j/log4j --\u003e \u003cdependency\u003e \u003cgroupId\u003elog4j\u003c/groupId\u003e \u003cartifactId\u003elog4j\u003c/artifactId\u003e \u003cversion\u003e1.2.17\u003c/version\u003e \u003c/dependency\u003e log4j.properties #将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码 log4j.rootLogger=DEBUG,console,file #控制台输出的相关设置 log4j.appender.console = org.apache.log4j.ConsoleAppender log4j.appender.console.Target = System.out log4j.appender.console.Threshold=DEBUG log4j.appender.console.layout = org.apache.log4j.PatternLayout log4j.appender.console.layout.ConversionPattern=[%c]-%m%n #文件输出的相关设置 log4j.appender.file = org.apache.log4j.RollingFileAppender log4j.appender.file.File=./log/miaobuyi.log log4j.appender.file.MaxFileSize=10mb log4j.appender.file.Threshold=DEBUG log4j.appender.file.layout=org.apache.log4j.PatternLayout log4j.appender.file.layout.ConversionPattern=[%p][%d{yy-MM-dd}][%c]%m%n #日志输出级别 log4j.logger.org.mybatis=DEBUG log4j.logger.java.sql=DEBUG log4j.logger.java.sql.Statement=DEBUG log4j.logger.java.sql.ResultSet=DEBUG log4j.logger.java.sql.PreparedStatement=DEBUG 配置log4j为日志的实现 \u003csettings\u003e \u003csetting name=\"logImpl\" value=\"LOG4J\"/\u003e \u003c/settings\u003e log4j的使用！直接运行刚才的查询 简单使用 在要使用log4j类中，导入包 import org.apache.log4j.Logger; 日志对象，参数为当前类的class static Logger logger = Logger.getLogger(UserMapperTest.class); 日志级别 logger.info(\"info:进入了testLog4j\"); logger.debug(\"debug:进入了testLog4j\"); logger.error(\"error:进入了testLog4j\"); ","date":"2021-09-21","objectID":"/mybatis/:6:2","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"6、分页 思考：为什么要分页 减少以数据的处理量 ","date":"2021-09-21","objectID":"/mybatis/:7:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"1、使用Limit分页 语法：SELECT * from user limit startIndex,pageSize select * from mybatis.user limit 3; #[0,n] 使用Mybatis分页，核心SQL 接口 List\u003cUser\u003e getUserByLimit(Map\u003cString,Integer\u003e map); Mapper.xml \u003cselect id=\"getUserByLimit\" resultMap=\"UserMap\" parameterType=\"map\"\u003e select * from mybatis.user limit #{startIndex},#{pageSize} \u003c/select\u003e 测试 @Test public void getUserByLimit(){ SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); HashMap\u003cString, Integer\u003e map = new HashMap\u003cString, Integer\u003e(); map.put(\"startIndex\",0); map.put(\"pageSize\",2); List\u003cUser\u003e userList = mapper.getUserByLimit(map); for (User user:userList){ System.out.println(user); } sqlSession.close(); } ","date":"2021-09-21","objectID":"/mybatis/:7:1","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"2、RowBounds【了解】 不再使用SQL实现分页 接口 List\u003cUser\u003e getUserByRowBounds(); mapper.xml \u003cselect id=\"getUserByRowBounds\" resultMap=\"UserMap\"\u003e select * from mybatis.user \u003c/select\u003e 测试 @Test public void getUserByRowBounds(){ SqlSession sqlSession = MybatisUtils.getSqlSession(); //RowBounds实现 RowBounds rowBounds = new RowBounds(1, 2); //通过java代码层面实现分页 List\u003cUser\u003e userList = sqlSession.selectList(\"com.miaobuyi.mapper.UserMapper.getUserByRowBounds\",null,rowBounds); for (User user:userList){ System.out.println(user); } sqlSession.close(); } ","date":"2021-09-21","objectID":"/mybatis/:7:2","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"3、插件分页【了解】 ","date":"2021-09-21","objectID":"/mybatis/:7:3","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"7、使用注解开发 ","date":"2021-09-21","objectID":"/mybatis/:8:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"1、面向接口编程 大家之前都学过面向对象编程，也学习过接口，但在真正的开发中，很多时候我们会选择面向接口编程 -根本原因∶解耦，可拓展，提高复用，分层开发中，上层不用管具体的实现，大家都遵守共同的标准，使得开发变得容易，规范性更好 在一个面向对象的系统中，系统的各种功能是由许许多多的不同对象协作完成的。在这种情况下.各个对象内部是如何实现自己的,对系统设计人员来讲就不那么重要了; 而各个对象之间的协作关系则成为系统设计的关键。小到不同类之间的通信，大到各模块之间的交互，在系统设计之初都是要着重考虑的，这也是系统设计的主要工作内容。面向接口编程就是指按照这种思想来编程。 关于接口的理解 接口从更深层次的理解，应是定义(规范，约束）与实现(名实分离的原则）的分离。 接口的本身反映了系统设计人员对系统的抽象理解。 接口应有两类: 第一类是对一个个体的抽象，它可对应为一个抽象体(abstract class); 第二类是对一个个体某一方面的抽象，即形成一个抽象面( interface) ; 一个体有可能有多个抽象面。抽象体与抽象面是有区别的。 三个面向区别 面向对象是指，我们考虑问题时，以对象为单位,考虑它的属性及方法. 面向过程是指，我们考虑问题时，以一个具体的流程(事务过程)为单位，考虑它的实现. 接口设计与非接口设计是针对复用技术而言的，与面向对象(过程)不是一一个问题.更多的体现就是对系统整体的 ","date":"2021-09-21","objectID":"/mybatis/:8:1","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"2、使用注解开发 注解在接口上实现 @Select(\"select * from user\") List\u003cUser\u003e getUsers(); 需要在核心配置文件中绑定接口 \u003c!-- 绑定接口--\u003e \u003cmappers\u003e \u003cmapper class=\"com.miaobuyi.mapper.UserMapper\"/\u003e \u003c/mappers\u003e 测试 @Test public void test(){ SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); List\u003cUser\u003e userList = mapper.getUsers(); for(User user:userList){ System.out.println(user); } sqlSession.close(); } 本质：反射机制实现 底层：动态代理！ Mybatis详细的执行流程！ ","date":"2021-09-21","objectID":"/mybatis/:8:2","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"8、Lombok 使用步骤 在IDEA中安装Lombok 在项目中导入Lombok的jar包 \u003c!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003cversion\u003e1.18.20\u003c/version\u003e \u003c/dependency\u003e @Getter and @Setter @FieldNameConstants @ToString @EqualsAndHashCode @AllArgsConstructor, @RequiredArgsConstructor and @NoArgsConstructor @Log, @Log4j, @Log4j2, @Slf4j, @XSlf4j, @CommonsLog, @JBossLog, @Flogger, @CustomLog @Data @Builder @SuperBuilder @Singular @Delegate @Value @Accessors @Wither @With @SneakyThrows @val @var experimental @var @UtilityClass @ExtensionMethod (Experimental, activate manually in plugin settings) @Data:无参构造，get，set，toString，hashcode，equals @AllArgsConstructor @NoArgsConstructor @FieldNameConstants @ToString ","date":"2021-09-21","objectID":"/mybatis/:9:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"9、多对一处理 多对一： 多个学生，对应一个老师 对于学生这边而言，关联。。对个学生，关联一个老师 对于老师而言，集合， 绿色：1 蓝色：∞ SQL： CREATE TABLE `teacher` ( `id` INT(10) NOT NULL, `name` VARCHAR(30) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=INNODB DEFAULT CHARSET=utf8; INSERT INTO teacher(`id`, `name`) VALUES (1, '秦老师'); CREATE TABLE `student` ( `id` INT(10) NOT NULL, `name` VARCHAR(30) DEFAULT NULL, `tid` INT(10) DEFAULT NULL, PRIMARY KEY (`id`), KEY `fktid` (`tid`), CONSTRAINT `fktid` FOREIGN KEY (`tid`) REFERENCES `teacher` (`id`) ) ENGINE=INNODB DEFAULT CHARSET=utf8; INSERT INTO `student` (`id`, `name`, `tid`) VALUES (1, '小明', 1); INSERT INTO `student` (`id`, `name`, `tid`) VALUES (2, '小红', 1); INSERT INTO `student` (`id`, `name`, `tid`) VALUES (3, '小张''', 1); INSERT INTO `student` (`id`, `name`, `tid`) VALUES (4, '小李', 1); INSERT INTO `student` (`id`, `name`, `tid`) VALUES (5, '小王', 1); ","date":"2021-09-21","objectID":"/mybatis/:10:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"测试环境搭建 导入Lombok 新建实体类Teacher，Student 建立Mapper接口 建立Mapper.XML文件 在核心配置文件中绑定注册我们的Mapper接口或者文件！【方式很多，随心选】 测试查询是否能能够成功 ","date":"2021-09-21","objectID":"/mybatis/:10:1","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"按照查询嵌套处理 \u003c!-- 思路: 1.查询所有的学生信息 2.根据查询出来的学生的tid，寻找对应的老师! 子查询 --\u003e \u003cselect id=\"getStudent\" resultmap=\"studentTeacher\"\u003e select * from student \u003c/se1ect\u003e \u003cresultMap id=\"StudentTeacher\" type=\"student\"\u003e \u003cresu1t property=\"id\" column=\"id\"/\u003e \u003cresu1t property=\"name\" column=\"name\"/\u003e \u003c!--复杂的属性，我们需要单独处理对象:association集合:collection --\u003e \u003cassociation property=\"teacher\" column=\"tid\" javaType=\"Teacher\" select=\"getTeacher\"/\u003e \u003c/resu1tMap\u003e \u003cselect id=\"getTeacher\" resultType=\"Teacher\"\u003e select * from teacher where id = #{id} \u003c/select\u003e ","date":"2021-09-21","objectID":"/mybatis/:10:2","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"按照结果嵌套处理 \u003cselect id=\"getStudent2\" resultMap=\"StudentTeacher2\"\u003e select s.id sid,s.name sname,t.name tname from student s,teacher t where s.tid = t.id \u003c/select\u003e \u003cresultMap id=\"StudentTeacher2\" type=\"Student\"\u003e \u003cresult property=\"id\" column=\"id\" /\u003e \u003cresult property=\"name\" column=\"name\"/\u003e \u003cassociation property=\"teacher\" javaType=\"Teacher\"\u003e \u003cresult property=\"name\" column=\"tname\"\u003e\u003c/result\u003e \u003c/association\u003e \u003c/resultMap\u003e 回顾Mysql多对一查询方式 子查询 联表查询 ","date":"2021-09-21","objectID":"/mybatis/:10:3","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"10、一对多处理 比如：一个老师拥有多个学生！ 对于老师而言就是一对多的关系！ ","date":"2021-09-21","objectID":"/mybatis/:11:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"环境搭建 环境搭建和刚才一样 实体类 @Data public class Student { private int id; private String name; private int tid; } @Data public class Teacher { private int id; private String name; //一个老师拥有多个学生 private List\u003cStudent\u003e students; } ","date":"2021-09-21","objectID":"/mybatis/:11:1","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"按照过嵌套处理 \u003cselect id=\"getTeacher\" resultMap=\"TeacherStudent\"\u003e select s.id sid ,s.name sname,t.name tname,t.id tid from student s,teacher t where s.tid = t.id and t.id = #{tid} \u003c/select\u003e \u003cresultMap id=\"TeacherStudent\" type=\"Teacher\"\u003e \u003cresult property=\"id\" column=\"tid\"/\u003e \u003cresult property=\"name\" column=\"tname\"/\u003e \u003ccollection property=\"students\" ofType=\"Student\"\u003e \u003cresult property=\"id\" column=\"sid\"/\u003e \u003cresult property=\"name\" column=\"sname\"/\u003e \u003cresult property=\"tid\" column=\"tid\"/\u003e \u003c/collection\u003e \u003c/resultMap\u003e ","date":"2021-09-21","objectID":"/mybatis/:11:2","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"按查询嵌套处理 \u003cselect id=\"getTeacher2\" resultMap=\"TeacherStudent2\"\u003e select * from mybatis.teacher where id = #{tid} \u003c/select\u003e \u003cresultMap id=\"TeacherStudent2\" type=\"Teacher\"\u003e \u003ccollection property=\"students\" javaType=\"ArrayList\" ofType=\"Student\" select=\"getStudentByTeacherId\" column=\"id\"/\u003e \u003c/resultMap\u003e \u003cselect id=\"getStudentByTeacherId\" resultType=\"Student\"\u003e select * from mybatis.student where tid=#{tid} \u003c/select\u003e 小结 关联 - association【多对一】 集合 - collection 【一对多】 javaType \u0026 ofType javaType 用来指定实体类中的属性类型 ofType 用来指定映射到List或者集合中的pojo类型中，泛型中的约束类型 注意点： 保证SQL的可读性，尽量保证通俗易懂 注意一对多和多对一中，属性名和字段的问题 如果问题不好排查错误，可以使用日志。建议使用log4j 面试高频 Mysql引擎 InnoDB一层原理 索引 索引优化！ ","date":"2021-09-21","objectID":"/mybatis/:11:3","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"11、动态SQL 什么是动态SQL：动态SQL就是根据不同条件生成不同的SQL语句 利用动态SQL这一特性可以彻底摆脱这种痛苦。 动态SQL元素和JSTL或基于类似XML的文本处理器相似。在MyBatis 之前的版本中，有很多元素需要花时间 了解。MyBatis 3大大精简了元素种类，现在只需学习原来一半的元素便可。MyBatis采用功能强大的基于OGNL 的表达式来淘汰其它大部分元素。 if choose (when， otherwise) trim (where， set) foreach ","date":"2021-09-21","objectID":"/mybatis/:12:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"搭建环境 CREATE TABLE `blog`( `id` VARCHAR(50) NOT NULL COMMENT '博客id', `title` varchar(100) NOT NULL COMMENT '博客标题', `author` varchar(30) NOT NULL COMMENT '博客作者', `create_time` datetime NOT NULL COMMENT '创建时间', `views` int(30) NOT NULL COMMENT '浏览量' )ENGINE=INNODB DEFAULT CHARSET=utf8 创建一个基础工程 导包 编写配置文件 编写实体类 @Data public class Blog { private int id; private String title; private String author; private Date creatTime; private int views; } 编写实体类对应的Mapper接口和Mapper.XML文件 ","date":"2021-09-21","objectID":"/mybatis/:12:1","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"IF \u003cselect id=\"queryBlogIf\" parameterType=\"map\" resultType=\"Blog\"\u003e select * from mybatis.blog where 1=1 \u003cif test=\"title != null\"\u003e and title = #{title} \u003c/if\u003e \u003cif test=\"author != null\"\u003e and author = #{author} \u003c/if\u003e \u003c/select\u003e ","date":"2021-09-21","objectID":"/mybatis/:12:2","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"choose (when， otherwise) \u003cselect id=\"queryBlogChoose\" parameterType=\"map\" resultType=\"Blog\"\u003e select * from mybatis.blog \u003cwhere\u003e \u003cchoose\u003e \u003cwhen test=\"title != null\"\u003e title = #{title} \u003c/when\u003e \u003cwhen test=\"title != null\"\u003e and authot = #{author} \u003c/when\u003e \u003cotherwise\u003e and views = #{views} \u003c/otherwise\u003e \u003c/choose\u003e \u003c/where\u003e \u003c/select\u003e ","date":"2021-09-21","objectID":"/mybatis/:12:3","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"trim (where， set)【trim可以自定义】 \u003cupdate id=\"updateBlog\" parameterType=\"map\" \u003e update mybatis.blog \u003cset\u003e \u003cif test=\"title != null\"\u003e title = #{title}, \u003c/if\u003e \u003cif test=\"author != null\"\u003e author = #{author}, \u003c/if\u003e \u003c/set\u003e where id = #{id} \u003c/update\u003e \u003ctrim prefix=\"\" prefixOverrides=\"\" suffix=\"\" suffixOverrides=\"\"\u003e \u003c/trim\u003e 所谓动态SQL，本质还是SQL语句，只是我们可以再SQL层面去执行一些逻辑代码 if where set choose when ","date":"2021-09-21","objectID":"/mybatis/:12:4","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"SQL片段 有的时候，我们可能会讲一些功能的部分抽取出来，方便复用 使用SQL标签抽取的公共部分 \u003csql id=\"if-title-author\"\u003e \u003cif test=\"title != null\"\u003e title = #{title} \u003c/if\u003e \u003cif test=\"author != null\"\u003e and author = #{author} \u003c/if\u003e \u003c/sql\u003e 在需要使用的地方使用include标签引用即可 \u003cselect id=\"queryBlogIf\" parameterType=\"map\" resultType=\"Blog\"\u003e select * from mybatis.blog \u003cwhere\u003e \u003cinclude refid=\"if-title-author\"\u003e\u003c/include\u003e \u003c/where\u003e \u003c/select\u003e ","date":"2021-09-21","objectID":"/mybatis/:12:5","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"Foreach select * from user where 1=1 and \u003cforeach item=\"id\" index=\"index\" collection=\"ids\" open=\"(\" separator = \"or\" close=\")\" #{id} \u003c/foreach\u003e (id = 1 or id=2 or id =3) \u003cselect id=\"queryBlogForeach\" parameterType=\"map\" resultType=\"Blog\"\u003e select * from mybatis.blog \u003cwhere\u003e \u003cforeach collection=\"ids\" item=\"id\" open=\"and (\" close=\")\" separator=\"or\"\u003e id = #{id} \u003c/foreach\u003e \u003c/where\u003e \u003c/select\u003e 动态SQL就是在拼接SQL语句，我们只要保证SQL的正确性，按照SQL的格式，去排列组合就可以了 建议 先在Mysql中写出完整的SQL，在对应的去修改成为我们的动态SQL实现通用 ","date":"2021-09-21","objectID":"/mybatis/:12:6","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"12、缓存 ","date":"2021-09-21","objectID":"/mybatis/:13:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"1、简介 查询 ：链接数据库 ，耗资源 一次查询的结果，给他暂存一个可以直接取到的地方！--\u003e内存 ：缓存 我们再次查询相同的数据的时候，直接走缓存，就不用走数据库了 什么是缓存[ Cache ]? 存在内存中的临时数据。 将用户经常查询的数据放在缓存(内存)中，用户去查询数据就不用从磁盘上(关系型数据库数据文件)查询，从缓存中查询，从而提高查询效率,解决了高并发系统的性能问题。 为什么使用缓存? 减少和数据库的交互次数,减少系统开销,提高系统效率。 什么样的数据能使用缓存? 经常查询并且不经常改变的数据。【可以使用缓存】 ","date":"2021-09-21","objectID":"/mybatis/:13:1","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"2、Mybatis缓存 MyBatis包含一个非常强大的查询缓存特性，它可以非常方便地定制和配置缓存。缓存可以极大的提升查询效 率。 MyBatis系统中默认定义了两级缓存: 一级缓存和二级缓存 默认情况下，只有一-级缓存开启。 (SqlSession级别的缓存， 也称为本地缓存) 二级缓存需要手动开启和配置， 他是基于namespace级别的缓存。 为了提高扩展性, MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存 ","date":"2021-09-21","objectID":"/mybatis/:13:2","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"3、一级缓存 一级缓存也叫本地缓存: SqlSession 与数据库同一次会话期间查询到的数据会放在本地缓存中。 以后如果需要获取相同的数据，直接从缓存中拿，没必须再去查询数据库; 测试步骤： 开启日志 测试在一个Session中查询两次相同的记录 查看日志输出 缓存失效的情况 查询不同的东西 增删改操作，可能会改变原来的数据，所以必定会刷新缓存！ 查询不同的Mapper.xml 手动清理缓存！ @Test public void test(){ SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); User user = mapper.queryUserById(1); System.out.println(user); sqlSession.clearCache();//手动清理缓存 System.out.println(\"=========================\"); User user2 = mapper.queryUserById(1); System.out.println(user2); System.out.println(user==user2); sqlSession.close(); } 小结：一级缓存默认是开启的，只有在一次SqlSession中有效，也就是拿到链接到关闭连接这个区间段！ 一级缓存就是一个Map ","date":"2021-09-21","objectID":"/mybatis/:13:3","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"4、 二级缓存 二级缓存也叫全局缓存，一级缓存作用域太低了，所以诞生了二级缓存 基于namespace级别的缓存， 一个名称空间，对应一 个二级缓存 工作机制 个会话查询一条数据，这个数据就会被放在当前会话的- -级缓存中 如果当前会话关闭了，这个会话对应的一级缓存就没了;但是我们想要的是，会话关闭了，一级缓存中的数据被保存到二级缓存中 新的会话查询信息，就可以从二级缓存中获取内容; 不同的mapper查出的数据会放在自己对应的缓存(map)中 步骤： 开启全局缓存 \u003c!-- 显示的开启全局缓存--\u003e \u003csetting name=\"cacheEnabled\" value=\"true\"/\u003exxxxxxxxxx2 1\u003c!-- 显示的开启全局缓存--\u003e2 \u003csetting name=\"cacheEnabled\" value=\"true\"/\u003e\u003csetting name=\"cacheEnabled\" value=\"true\"/\u003e 再要使用deMapper中开启 \u003c!-- 在当前xml中使用缓存--\u003e \u003ccache/\u003e 也可以自定义参数 \u003ccache eviction=\"FIFO\" flushInterval=\"60000\" size=\"512\" readOnly=\"true\"/\u003e 测试 问题：我们需要将实体类序列化！否则就会报错！ Caused by: java. io. NotSerializableExcepti on:com.miaobuyi.pojo.user @Data public class User implements Serializable { private int id; private String name; private String pwd; } 小结： 只要开启了二级缓存，在同一个Mapper下就有效 所有的数据都会先放在一级缓存中 只有当回话提交或者关闭的时候，才会提交到二级缓存中！ ","date":"2021-09-21","objectID":"/mybatis/:13:4","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"5、缓存原理 ","date":"2021-09-21","objectID":"/mybatis/:13:5","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"6、自定义缓存-ehcache Redis数据库来做缓存！ K-V ","date":"2021-09-21","objectID":"/mybatis/:13:6","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["设计模式"],"content":"Day6 C语言 ","date":"2021-09-21","objectID":"/01.%E8%B5%B5%E5%85%B4%E5%8D%8E%E6%B8%85%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%B9%E8%AE%AD-c%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/:1:0","tags":["单例模式"],"title":"设计模式","uri":"/01.%E8%B5%B5%E5%85%B4%E5%8D%8E%E6%B8%85%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%B9%E8%AE%AD-c%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"},{"categories":["设计模式"],"content":"输入输出画家音乐家和 -getchar()\\putchar() getchar()会接受一切字符，包括空格、回车 printf()\\scanf() %d 整形 %c 字符 %f 单精度 %d 双精度 %p 地址 %s 字符串 — scanf() 解决垃圾字符 抑制符 指定输入项后的内容不输入 用getchar()处理 在连续输入字符的中间加上空格 遇到空格，就相当于另外一个字符串 gets()\\puts() gets() 功能：从键盘输入一个指定的字符串 gets(输入字符串的首地址) char a[10]=\"HELLO\"; gets(a); ","date":"2021-09-21","objectID":"/01.%E8%B5%B5%E5%85%B4%E5%8D%8E%E6%B8%85%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%B9%E8%AE%AD-c%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/:1:1","tags":["单例模式"],"title":"设计模式","uri":"/01.%E8%B5%B5%E5%85%B4%E5%8D%8E%E6%B8%85%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%B9%E8%AE%AD-c%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"},{"categories":["设计模式"],"content":"要注意栈溢出 puts() 功能：向终端输出一个指定的字符串 puts(输出内容首地址); char a[10]=\"HELLO\"; puts(a); * ##### 自带换行 不用加\"\\n\" 获取随机的时间种子 srand((unsigned)time(NULL)); rand(); ","date":"2021-09-21","objectID":"/01.%E8%B5%B5%E5%85%B4%E5%8D%8E%E6%B8%85%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%B9%E8%AE%AD-c%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/:2:0","tags":["单例模式"],"title":"设计模式","uri":"/01.%E8%B5%B5%E5%85%B4%E5%8D%8E%E6%B8%85%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%B9%E8%AE%AD-c%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"},{"categories":["设计模式"],"content":"Day6 Linux man命令（手册） ","date":"2021-09-21","objectID":"/01.%E8%B5%B5%E5%85%B4%E5%8D%8E%E6%B8%85%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%B9%E8%AE%AD-c%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/:3:0","tags":["单例模式"],"title":"设计模式","uri":"/01.%E8%B5%B5%E5%85%B4%E5%8D%8E%E6%B8%85%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%B9%E8%AE%AD-c%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"},{"categories":["设计模式"],"content":"Day7 C语言 数组初始化 完全初始化 int a[5]={1,2,3,4,5}; 不完全初始化，其余初始化的元素默认为0 int b[5]={1,2,3}; 不指定元素个数，根据给定的来分配 int c[]={1,2,3,4,5} 寻找素数的方法—https://zhuanlan.zhihu.com/p/104314640 方法3：普通筛法——埃拉托斯特尼(Eratosthenes)筛法 思路: 我们的想法是，创建一个比范围上限大1的数组，我们只关注下标为 1 ~ N（要求的上限） 的数组元素与数组下标（一一对应）。 将数组初始化为1。然后用for循环，遍历范围为：【2 ~ sqrt(N)】。如果数组元素为1，则说明这个数组元素的下标所对应的数是素数。 随后我们将这个下标（除1以外）的整数倍所对应的数组元素全部置为0，也就是判断其为非素数。 这样，我们就知道了范围内（1 ~ 范围上限N）所有数是素数（下标对应的数组元素值为1）或不是素数（下标对应的数组元素值为0） 用百度百科对埃拉托斯特尼筛法简单描述：要得到自然数n以内的全部素数，必须把不大于 的所有素数的倍数剔除，剩下的就是素数。 核心代码： // 判断素数的数组 范围上限N void Eratprime(int* isprime, int upper_board) { int i = 0; int j = 0; //初始化isprime for (i = 2; i \u003c= upper_board; i++) isprime[i] = 1; for (i = 2; i \u003c (int)sqrt(upper_board); i++) { if (isprime[i]) { isprime[i] = 1; } for (j = 2; i * j \u003c= upper_board; j++) {//素数的n倍（n \u003e= 2）不是素数 isprime[i * j] = 0; } } } 方法4：线性筛法——欧拉筛法 思路: 我们再思考一下上面的埃拉托斯特尼筛法，会发现，在“剔除“非素数时，有些合数会重复赋值。这样就增加里复杂度，降低了效率。 比如：范围上限N = 16时 2是素数，剔除”2 的倍数“，他们是：4，6， 8，10， 12， 14， 16 3是素数，剔除”3 的倍数”，他们时，6，9，12，15 6，12是重复的。如何减少重复呢？ 核心代码： void PrimeList(int* Prime, bool* isPrime, int n) { int i = 0; int j = 0; int count = 0; if (isPrime != NULL) {//确保isPrime不是空指针 //将isPrime数组初始化为 1 for (i = 2; i \u003c= N; i++) { isPrime[i] = true; } } if (isPrime != NULL \u0026\u0026 Prime != NULL) { //从2遍历到范围上限N for (i = 2; i \u003c= N; i++) { if (isPrime[i])//如果下标（下标对应着1 ~ 范围上限N）对应的isPrime值没有被置为false，说明这个数是素数，将下标放入素数数组 Prime[count++] = i; //循环控制表达式的意义：j小于等于素数数组的个数 或 素数数组中的每一个素数与 i 的积小于范围上限N for (j = 0; (j \u003c count) \u0026\u0026 (Prime[j] * (long long)i) \u003c= N; j++)//将i强制转换是因为vs上有warning，要求转换为宽类型防止算术溢出。数据上不产生影响 { isPrime[i * Prime[j]] = false;//每一个素数的 i 倍（i \u003e= 2）都不是素数，置为false //这个是欧拉筛法的核心，它可以减少非素数置false的重复率 //意义是将每一个合数（非素数）拆成 2（最小因数）与最大因数 的乘积 if (i % Prime[j] == 0) break; } } } } ","date":"2021-09-21","objectID":"/01.%E8%B5%B5%E5%85%B4%E5%8D%8E%E6%B8%85%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%B9%E8%AE%AD-c%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/:4:0","tags":["单例模式"],"title":"设计模式","uri":"/01.%E8%B5%B5%E5%85%B4%E5%8D%8E%E6%B8%85%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%B9%E8%AE%AD-c%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"},{"categories":["设计模式"],"content":"Day8 C语言 /x 表示16进制 printf(\"%c\\n\",\"/x69\"); output---\u003e i 结果为i -\u003ethe reason is 十六进制 69 对应的十进制为105，从ASCLL表中可以查到105对于为i fflush(stdout); 刷新缓冲区， 如果不加fflush(),则程序不会输出，需要等程序结束后才会输出。原因是以为缓冲区。 \\r表示光标移动到改行的首位 \\n表示移动到下一行 写程序时通常只写\\n，程序回自动变成\\r\\n %s 表示输入整个字符串 存储类型—-\u003e变量的存储类型关系到变量的存储位置，C语言中定义了4种存储属性，即 自动变量 (auto)、外部变量 (extern)、静态变量 (static)和寄存器变量 (register) ，它关系到变量在内存中的存放位置，由此决定了变量的保留时间和变量的作用范围。 ","date":"2021-09-21","objectID":"/01.%E8%B5%B5%E5%85%B4%E5%8D%8E%E6%B8%85%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%B9%E8%AE%AD-c%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/:5:0","tags":["单例模式"],"title":"设计模式","uri":"/01.%E8%B5%B5%E5%85%B4%E5%8D%8E%E6%B8%85%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%B9%E8%AE%AD-c%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"},{"categories":["设计模式"],"content":"Day 09 C语言 #if 条件编译 **这种能够根据不同情况编译不同代码、产生不同目标文件的机制，称为条件编译。**条件-编译是预处理程序的功能，不是编译器的功能。 这些操作都是在预处理阶段完成的，多余的代码以及所有的宏都不会参与编译，不仅保证了代码的正确性，还减小了编译后文件的体积。 e.g. #include \u003cstdio.h\u003e int main(){ #if _WIN32 system(\"color 0c\"); printf(\"http://c.biancheng.net\\n\"); #elif __linux__ printf(\"\\033[22;31mhttp://c.biancheng.net\\n\\033[22;30m\"); #else printf(\"http://c.biancheng.net\\n\"); #endif return 0; } #if、#elif、#else 和 #endif 都是预处理命令，整段代码的意思是：如果宏 _WIN32 的值为真，就保留第 4、5 行代码，删除第 7、9 行代码；如果宏 linux 的值为真，就保留第 7 行代码；如果所有的宏都为假，就保留第 9 行代码。 用法**（需要注意的是，#if 命令要求判断条件为“整型常量表达式”）** #if 整型常量表达式1 程序段1 #elif 整型常量表达式2 程序段2 #elif 整型常量表达式3 程序段3 #else 程序段4 #endif ","date":"2021-09-21","objectID":"/01.%E8%B5%B5%E5%85%B4%E5%8D%8E%E6%B8%85%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%B9%E8%AE%AD-c%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/:6:0","tags":["单例模式"],"title":"设计模式","uri":"/01.%E8%B5%B5%E5%85%B4%E5%8D%8E%E6%B8%85%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%B9%E8%AE%AD-c%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"},{"categories":["设计模式"],"content":"Day10 C语言 地址存放问题 在c语言中，局部变量存放在栈中其地址是从低到高，即先声明的在内存的低位，后声明的在内存的高位。类似于栈的操作，先进后出 其他类型的变量都是正常存放，即照顺序存放。 ","date":"2021-09-21","objectID":"/01.%E8%B5%B5%E5%85%B4%E5%8D%8E%E6%B8%85%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%B9%E8%AE%AD-c%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/:6:1","tags":["单例模式"],"title":"设计模式","uri":"/01.%E8%B5%B5%E5%85%B4%E5%8D%8E%E6%B8%85%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%B9%E8%AE%AD-c%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"},{"categories":["设计模式"],"content":"第二周周末 C语言 同样地址问题,多字节数据，高位存放在高地址，地位存放在地址。例 other: ","date":"2021-09-21","objectID":"/01.%E8%B5%B5%E5%85%B4%E5%8D%8E%E6%B8%85%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%B9%E8%AE%AD-c%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/:6:2","tags":["单例模式"],"title":"设计模式","uri":"/01.%E8%B5%B5%E5%85%B4%E5%8D%8E%E6%B8%85%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%B9%E8%AE%AD-c%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"},{"categories":["设计模式"],"content":"Day11 C语言 野指针 野指针：定义一个指针，没有明确指向，不能访问野指针，且程序不会报错。 其地址位0000000000000000 错误用法 正确 指针运算 指针运算中，没有指针加指针，指针乘指针，指针除指针 但是有指针减指针 作用： 表示相同类型之间的两个指针之间相差多少个元素，结果的正负，仅代表地址高低 指针与二维数组 本质：数组指针是一个指针，存放的是内容是地址，指向的内容是一个以为数组 二维数组的数组名是一个行指针，指向二维数组额首地址，行指针+n相当于地址偏离n行元素 行指针的定义的一般形式 \u003c存储类型\u003e \u003c数据类型\u003e (*指针变量名)[列数] int a[2][3]={1,2,3,4,5,6}; int(*p)[3]=a; 例如 #include \u003cstdio.h\u003e int main() { int a[2][3]={1,2,3,4,5,6}; int(*p)[3]=a; printf(\"**p %d\\n\",**p); printf(\"**p+1 %d\\n\",**p+1); printf(\"**(p+1) %d\\n\",*(*(p)+1)); printf(\"**(p+1) %d\\n\",*(*(p)+2)); printf(\"**(p+1) %d\\n\",**(p+1)); return 0; } 大端序和小端序 所有x86的计算机都是小端序，arm架构和网络编程中都是大端序 ","date":"2021-09-21","objectID":"/01.%E8%B5%B5%E5%85%B4%E5%8D%8E%E6%B8%85%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%B9%E8%AE%AD-c%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/:7:0","tags":["单例模式"],"title":"设计模式","uri":"/01.%E8%B5%B5%E5%85%B4%E5%8D%8E%E6%B8%85%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%B9%E8%AE%AD-c%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"},{"categories":["设计模式"],"content":"单例模式 饿汉式单例 //饿汉式单例 public class Hungry { //可能会浪费空间 private byte[] datal = new byte [1024*1024]; private byte[] data2 = new by mte [1024*1024]; private byte[] data3 = new byte [1024*1024]; private byte[] data4 = new byte [1024*1024]; private Hungry(){ } private fina1 static Hungry HUNGRY = new Hungry(); public static Hungry getInstance() { return HUNGRY; } } DCL懒汉式 //懒汉式单例 public class LazyMan { private static boolean qinjiang = false; private LazyMan(){ synchronized (LazyMan. class){ if (qinjiang == false){ qinjiang = true; }else {| throw new RuntimeException(\"不 要试图使用反射破坏异常\"); } } } private volatile static LazyMan LazyMan; //双重检测锁模式的懒汉式单例DCL 懒汉式 public static LazyMan getInstance( ){ if (LazyMan==nu1l){ synchronized (LazyMan. class){ if (LazyMan==nu1l){ lazyMan = new LazyMan(); //不是一个原子性操作 } } } return LazyMan; } //反射! public static void main(String[] args) throws Exception { LazyMan instance = LazyMan.getInstance(); Field qinjiang = LazyMan.class.getDeclaredField( name: \"qinjiang\"); qinjiang. setAccessible(true); Constructor\u003cLazyMan\u003e declaredConstructor = LazyMan. class. getDeclaredConstructor(null) declaredConstructor . setAccessible(true); LazyManτ instance = declaredConstructor.newInstance(); qinjiang. set(instance,false); LazyMan instance2 = declaredConstructor.newInstance(); System.out.print1n(instance); System.out.print1n(instance2); } 静态内部类 // 静态内部类 public class Holder { private Holder(){ } pub1ic static Holder getInstace(){ return InnerClass. HOLDER; } pub1ic static class InnerClass{ private static final Holder HOLDER = new Holder(); } 单例不安全，反射 枚举 import java.lang.reflect.Constructor; import java.lang.reflect.InvocationTargetException; //enum是一个什么?本身也是 一个CLass类 public enum EnumSingle { INSTANCE; public EnumSingle getInstance(){ return INS TANCE ; class Test{ public static void main(String[] args) throws Exception{ EnumSingle instance1 = EnumSingle.INSTANCE; Constructor\u003cEnumSingle\u003e declaredConstructor = EnumSingle.class.getDeclaredConstructor(String.class,int.class) declaredConstructor.setAccessible(true); EnumSingle instance2 = declaredConstructor . newInstance(); // NoSuchMethodException: com. kuang. single. EnumSingle. \u003cinit\u003e() System.out.println( instance1); System.out.println( instance2); } } 枚举的最终反编译 pub1ic static Enumsing1e[] values(){ return (EnumSingle[]) $VALUES. clone(); } public static EnumSingle valueOf (String name){ return (EnumS ing1e)Enum. valueOf (com/kuang/s ing1e/Enumsingle, name); } private Enumsingle(String S，int i){ super(s，i); } public EnumSingle getInstance(){ return INSTANCE; } public static final EnumSingle INSTANCE; private static final EnumSingle $VALUES[]; static{ INSTANCE = new EnumSingle(\"INSTANCE\"，0); $VALUES = (new EnumSing1e[] { INSTANCE }); } ","date":"2021-09-21","objectID":"/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:1:0","tags":["单例模式"],"title":"设计模式","uri":"/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["框架"],"content":"1、Spring ","date":"2021-09-21","objectID":"/spring/:1:0","tags":["Spring","Mybatis"],"title":"Spring","uri":"/spring/"},{"categories":["框架"],"content":"1、简介 2002 ，首次推出了Spring框架的雏形：interface21框架 2004-3-24正式发布1.0版本，Spring框架以interface21框架为基础，经过重新设计，并不对丰富其内涵 Rod Johnson，Spring框架的创始人 spring的理念：使现有的技术更加容易使用，本身是一个大杂烩，整合了现有的技术框架 SSH ： Struct + Spring + Hibernate！ SSM ： SpringMVC + Spring + Mybatis！ maven \u003c!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-webmvc\u003c/artifactId\u003e \u003cversion\u003e5.3.9\u003c/version\u003e \u003c/dependency\u003e ","date":"2021-09-21","objectID":"/spring/:1:1","tags":["Spring","Mybatis"],"title":"Spring","uri":"/spring/"},{"categories":["框架"],"content":"2.优点 Spring是一个开源的免费的框架（容器）！ Spring是一个轻量级，非入侵式的容器！ 控制翻转（IOC），面向切面编程（AOP） 支持事务的处理，对框架整合的支持 总结一句话：Spring就是一个轻量级的控制反转（IOC)和面向切面(AOP)的框架 ","date":"2021-09-21","objectID":"/spring/:1:2","tags":["Spring","Mybatis"],"title":"Spring","uri":"/spring/"},{"categories":["框架"],"content":"3、组成 ","date":"2021-09-21","objectID":"/spring/:1:3","tags":["Spring","Mybatis"],"title":"Spring","uri":"/spring/"},{"categories":["框架"],"content":"4、拓展 在Spring的官网有这个介绍：现代化的java开发！说白了就是基于Spring开发 Srping Boot 一个快速开发的脚手架 基于SpringBoot可以快速的开发单个微服务 约定大于配置！ Spring Cloud SpringCloud是基于SpringBoot实现的。 因为现在大多数公司都在使用SpringBoot进行快速开发，学习SpringBoot的前提，需要完全掌握Srping和SpringMVC 弊端：发展了太久之后，违背了原来的理念！配置十分繁琐，人称“配置地狱！” ","date":"2021-09-21","objectID":"/spring/:1:4","tags":["Spring","Mybatis"],"title":"Spring","uri":"/spring/"},{"categories":["框架"],"content":"2、IOC理论推导 UserDao接口 UserDaoImpl实现类 USerService业务接口 UserServiceUmpl业务实现类 在我们之前的业务中，用户的需求可能会影响我们原来的代码，我们需要根据用户的需求去修改源代码！如果程序代码量十分大，修改一次的代码代价十分昂贵！ 我们使用一个Set接口实现 private UserMapper userMapper = new UserMapperImpl(); //利用set进行动态实现值得注入 public void setUserMapper(UserMapper userMapper) { this.userMapper = userMapper; } 之前，程序是主动创建对象！控制权在程序猿手上 使用set注入后，程序不在具有主动性，而是变成了被动的接受对象 这种思想，从本质上解决了问题，我们程序猿不再去管理对象的创建。系统的耦合性大大减低，可以更加专注地在业务的实现上！这是IOC的原型！ ","date":"2021-09-21","objectID":"/spring/:2:0","tags":["Spring","Mybatis"],"title":"Spring","uri":"/spring/"},{"categories":["框架"],"content":"IOC本质 控制反转loC(Inversion of Control),是-种设计思想，DI(依赖注入)是实现IoC的一种方法，也有人认为DI只是IoC的另一种说法。 没有IoC的程序中,我们使用面向对象编程,对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是:获得依赖对象的方式反转了。 采用XML方式配置Bean的时候，Bean的定 义信息是和实现分离的，而采用注解的方式可以把两者合为一体,Bean的定义信息直接以注解的形式定义在实现类中，从而达到了零配置的目的。 控制反转是一种通过描述(XML或注解) 并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IoC容器，其实现方法是依赖注入(Dependency Injection,DI)。 IOC实际上是对象由spring创建，管理，装配 ","date":"2021-09-21","objectID":"/spring/:2:1","tags":["Spring","Mybatis"],"title":"Spring","uri":"/spring/"},{"categories":["框架"],"content":"3、HelloSpring ","date":"2021-09-21","objectID":"/spring/:3:0","tags":["Spring","Mybatis"],"title":"Spring","uri":"/spring/"},{"categories":["框架"],"content":"1.导入Spring相关的Jar包 注：Spring需要导入commons-logging进行日志记录，我们利用maven，它会自动下载对应的依赖项 \u003c!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-webmvc\u003c/artifactId\u003e \u003cversion\u003e5.3.9\u003c/version\u003e \u003c/dependency\u003e ","date":"2021-09-21","objectID":"/spring/:3:1","tags":["Spring","Mybatis"],"title":"Spring","uri":"/spring/"},{"categories":["框架"],"content":"2、编写相关代码 编写一个Hello实体类 package com.miaobuyi.pojo; public class Hello { private String str; public String getStr() { return str; } public void setStr(String str) { this.str = str; } @Override public String toString() { return \"Hello{\" + \"str='\" + str + '\\'' + '}'; } } 在xml中注册 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u003c!-- 使用Spring来创建对洗那个，在Spring这些都成为Bean 类型 变量名 = new 类型(); Hello hello = new Hello(); bean = 对象 new Hello(); id = 变量名 class = new 的对象 property 相当于给对象中的属性设置一个值 --\u003e \u003cbean id=\"hello\" class=\"com.miaobuyi.pojo.Hello\"\u003e \u003cproperty name=\"str\" value=\"Spring\"/\u003e \u003c/bean\u003e \u003c/beans\u003e 测试类 import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class MyTest { public static void main(String[] args) { //获取Spring的上下文对象！ ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); //我们的对象都在Spring中管理了，我们要使用，直接去里面取出来就可以了！ Object hello = context.getBean(\"hello\"); System.out.println(hello.toString()); } } 思考问题? Hello对象是谁创建的? hello对象是由Spring创建的 Hello 对象的属性是怎么设置的? hello对象的属性是由Spring容器设置的， 这个过程就叫控制反转 : 控制：谁来控制对象的创建,传统应用程序的对象是由程序本身控制创建的,使用Spring后,对象是由Spring来创建的. 反转：程序本身不创建对象,而变成被动的接收对象. I依赖注入：就是利用set方法来进行注入的. IOC是一种编程思想,由主动的编程变成被动的接收. 可以通过newClassPathXmlApplicationContext去浏览一下底层源码 . OK,到了现在,我们彻底不用再程序中去改动了,要实现不同的操作,只需要在xml配置文件中进行修改,所谓的loC,一句话搞定:对象由Spring来创建,管理,装配! ","date":"2021-09-21","objectID":"/spring/:3:2","tags":["Spring","Mybatis"],"title":"Spring","uri":"/spring/"},{"categories":["框架"],"content":"4、IOC创建对象的方式 使用无参构造创建对象，默认 假设我们要使用有参构造创建对象 下标赋值 \u003cbean id=\"user\" class=\"com.miaobuyi.pojo.User\" \u003e \u003cconstructor-arg index=\"0\" value=\"喵不易学java\"/\u003e \u003c/bean\u003e 类型 \u003cbean id=\"user\" class=\"com.miaobuyi.pojo.User\"\u003e \u003cconstructor-arg type=\"java.lang.String\" value=\"miaobuyi\"/\u003e \u003c/bean\u003e 参数名 \u003cbean id=\"user\" class=\"com.miaobuyi.pojo.User\"\u003e \u003cconstructor-arg name=\"name\" value=\"喵不易\"/\u003e \u003c/bean\u003e 总结：在配置文件加载的时候，容器中管理的对象就已经初始化了 ","date":"2021-09-21","objectID":"/spring/:4:0","tags":["Spring","Mybatis"],"title":"Spring","uri":"/spring/"},{"categories":["框架"],"content":"5、Spring配置 ","date":"2021-09-21","objectID":"/spring/:5:0","tags":["Spring","Mybatis"],"title":"Spring","uri":"/spring/"},{"categories":["框架"],"content":"1、别名 \u003c!-- 别名，如果添加了别名，我们也可以使用别名获取到这个对象--\u003e \u003calias name=\"user\" alias=\"usernew\"/\u003e ","date":"2021-09-21","objectID":"/spring/:5:1","tags":["Spring","Mybatis"],"title":"Spring","uri":"/spring/"},{"categories":["框架"],"content":"2、Bean的配置 \u003c!-- id：bean的唯一标识符，也就是相当于我们学的对象名 class：bean对选哪个所对应的全限定名：包名+类型 name：也是别名，而且name更高级 可以同时取多个别名 --\u003e \u003cbean id=\"user\" class=\"com.miaobuyi.pojo.User\" name=\"userNew,u2\" \u003e \u003cconstructor-arg name=\"name\" value=\"喵不易\"/\u003e \u003c/bean\u003e ","date":"2021-09-21","objectID":"/spring/:5:2","tags":["Spring","Mybatis"],"title":"Spring","uri":"/spring/"},{"categories":["框架"],"content":"3、import 这个import，一般用于团队开发使用，他可以将多个配置文件导入合并为一个 假设，现在项目中有多个人开发，这三个人负责不同的类开发，不同的类需要注册在不同的bean中，我们可以利用import将所有人beans.xml合并为一个总的！ 张三 李四 王五 applicationContext.xml \u003cimport resource=\"beans.xml\"/\u003e 使用的时候直接使用总的配置就可以了 ","date":"2021-09-21","objectID":"/spring/:5:3","tags":["Spring","Mybatis"],"title":"Spring","uri":"/spring/"},{"categories":["框架"],"content":"6、DI依赖注入 ","date":"2021-09-21","objectID":"/spring/:6:0","tags":["Spring","Mybatis"],"title":"Spring","uri":"/spring/"},{"categories":["框架"],"content":"1、构造器注入 前面有 ","date":"2021-09-21","objectID":"/spring/:6:1","tags":["Spring","Mybatis"],"title":"Spring","uri":"/spring/"},{"categories":["框架"],"content":"2、Set方式注入【重点 】 依赖注入：Set注入 依赖：bean对象的创建依赖于容器！ 注入：bean对象中的所有属性，由容器注入 【环境搭建】 复杂类型 package com.miaobuyi.pojo; public class Address { private String address; public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } } 真实测试对象 public class Student { private String name; private Address address ; private String[] books ; private List\u003cString\u003e hobbys; private Map\u003cString, String\u003e card; private Set\u003cString\u003e games; private String wife; private Properties info; } beans.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u003cbean id=\"student\" class=\"com.miaobuyi.pojo.Student\"\u003e \u003c!-- 第一种，普通值注入 value--\u003e \u003cproperty name=\"name\" value=\"喵不易\"/\u003e \u003c/bean\u003e \u003c/beans\u003e 测试类 import com.miaobuyi.pojo.Student; import org.springframework.context.support.ClassPathXmlApplicationContext; public class MyTest { public static void main(String[] args) { ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); Student student = (Student) context.getBean(\"student\"); System.out.println(student); } } 完善注入信息 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u003cbean id=\"address\" class=\"com.miaobuyi.pojo.Address\"\u003e \u003cproperty name=\"address\" value=\"成都\"/\u003e \u003c/bean\u003e \u003cbean id=\"student\" class=\"com.miaobuyi.pojo.Student\"\u003e \u003c!-- 第一种，普通值注入 value--\u003e \u003cproperty name=\"name\" value=\"喵不易\"/\u003e \u003c!-- 第二种，Bean注入 ref--\u003e \u003cproperty name=\"address\" ref=\"address\"/\u003e \u003c!-- 数组注入--\u003e \u003cproperty name=\"books\"\u003e \u003carray\u003e \u003cvalue\u003e红楼梦\u003c/value\u003e \u003cvalue\u003e西游记\u003c/value\u003e \u003cvalue\u003e水浒传\u003c/value\u003e \u003cvalue\u003e三国演义\u003c/value\u003e \u003c/array\u003e \u003c/property\u003e \u003c!-- List注入--\u003e \u003cproperty name=\"hobbys\"\u003e \u003clist\u003e \u003cvalue\u003e听歌\u003c/value\u003e \u003cvalue\u003e敲代码\u003c/value\u003e \u003cvalue\u003e看电影\u003c/value\u003e \u003c/list\u003e \u003c/property\u003e \u003c!-- Map注入--\u003e \u003cproperty name=\"card\"\u003e \u003cmap\u003e \u003centry key=\"省份证\" value=\"1321321321\"/\u003e \u003centry key=\"银行卡\" value=\"64654654\"/\u003e \u003c/map\u003e \u003c/property\u003e \u003c!-- Set注入--\u003e \u003cproperty name=\"games\"\u003e \u003cset\u003e \u003cvalue\u003eLOL\u003c/value\u003e \u003cvalue\u003eCOC\u003c/value\u003e \u003cvalue\u003eBOB\u003c/value\u003e \u003c/set\u003e \u003c/property\u003e \u003c!-- Null注入--\u003e \u003cproperty name=\"wife\"\u003e \u003cnull/\u003e \u003c/property\u003e \u003c!-- Properties注入--\u003e \u003cproperty name=\"info\"\u003e \u003cprops\u003e \u003cprop key=\"学号\"\u003e15846532\u003c/prop\u003e \u003cprop key=\"性别\"\u003e男\u003c/prop\u003e \u003cprop key=\"姓名\"\u003e张三\u003c/prop\u003e \u003c/props\u003e \u003c/property\u003e \u003c/bean\u003e \u003c/beans\u003e ","date":"2021-09-21","objectID":"/spring/:6:2","tags":["Spring","Mybatis"],"title":"Spring","uri":"/spring/"},{"categories":["框架"],"content":"3、拓展方式注入 我们可以使用p命名空间和c命名空间进行注入 官方解释： \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:c=\"http://www.springframework.org/schema/c\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u003c!--p命名空间注入，可以直接注入属性的值：properties--\u003e \u003cbean id=\"user\" class=\"com.miaobuyi.pojo.User\" p:name=\"喵不易\" p:age=\"18\"/\u003e \u003c!--c命名空间注入，可以直接注入属性的值：construct--\u003e \u003cbean id=\"user2\" class=\"com.miaobuyi.pojo.User\" c:age=\"18\" c:name=\"喵不易\"/\u003e \u003c/beans\u003e 测试： @Test public void test2(){ ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"userbeans.xml\"); User user = context.getBean(\"user2\", User.class); System.out.println(user); } 注意点：p命名和c命名不能直接使用，需要导入xml约束 ","date":"2021-09-21","objectID":"/spring/:6:3","tags":["Spring","Mybatis"],"title":"Spring","uri":"/spring/"},{"categories":["框架"],"content":"4、Bean的作用域 单例模式（Spring默认机制） \u003cbean id=\"user2\" class=\"com.miaobuyi.pojo.User\" c:age=\"18\" c:name=\"喵不易\" scope=\"singleton\"/\u003e 原型模式：每次从容器中get的时候，都会产生一个新对象！ \u003cbean id=\"user2\" class=\"com.miaobuyi.pojo.User\" c:age=\"18\" c:name=\"喵不易\" scope=\"prototype\"/\u003e 其余的 request、session、application这些只能在web开放中使用 ","date":"2021-09-21","objectID":"/spring/:6:4","tags":["Spring","Mybatis"],"title":"Spring","uri":"/spring/"},{"categories":["框架"],"content":"7、Bean的自动装配 自动装配是Spring满足Bean依赖的一种方式！ Spring会在上下文中自动寻找，并自动给bean装配属性！ 在Spring中有三种装配的方式 在xml中显示的配置 在Java中显示配置 隐式的自动装配bean【重要】 ","date":"2021-09-21","objectID":"/spring/:7:0","tags":["Spring","Mybatis"],"title":"Spring","uri":"/spring/"},{"categories":["框架"],"content":"1、测试 环境搭建：一个人有两个宠物！ ","date":"2021-09-21","objectID":"/spring/:7:1","tags":["Spring","Mybatis"],"title":"Spring","uri":"/spring/"},{"categories":["框架"],"content":"2、byName自动装配 \u003cbean id=\"cat\" class=\"com.miaobuyi.pojo.Cat\"/\u003e \u003cbean id=\"dog\" class=\"com.miaobuyi.pojo.Dog\"/\u003e \u003c!-- byName:会自动在容器上下文中查找，和自己对象set方法后面的值对应的bean id --\u003e \u003cbean id=\"people\" class=\"com.miaobuyi.pojo.People\" autowire=\"byName\"\u003e \u003cproperty name=\"name\" value=\"喵不易\"/\u003e \u003c/bean\u003e ","date":"2021-09-21","objectID":"/spring/:7:2","tags":["Spring","Mybatis"],"title":"Spring","uri":"/spring/"},{"categories":["框架"],"content":"3、byType自动装配 \u003cbean id=\"cat\" class=\"com.miaobuyi.pojo.Cat\"/\u003e \u003cbean id=\"dog11\" class=\"com.miaobuyi.pojo.Dog\"/\u003e \u003c!-- byType:会自动在容器上下文中查找，和自己对象属性类型相同的bean --\u003e \u003cbean id=\"people\" class=\"com.miaobuyi.pojo.People\" autowire=\"byType\"\u003e \u003cproperty name=\"name\" value=\"喵不易\"/\u003e \u003c/bean\u003e 小结： byName的时候，需要保证所有bean的id唯一，并且这个bean需要和自动注入的属性的set方法的值一致！ byType的时候，需要保证所有bean的class唯一，并且这个bean需要和自动注入的属性的类型一致！ ","date":"2021-09-21","objectID":"/spring/:7:3","tags":["Spring","Mybatis"],"title":"Spring","uri":"/spring/"},{"categories":["框架"],"content":"4、使用注解实现自动装配 autowire 先byType，如果类型大于1，再byName jdk1.5支持的注解，Spring2.5就支持注解了！ 基于注释的配置的引入提出了一个问题，即这种方法是否比XML“更好”。 要使用注解须知： 导入约束 context约束 配置注解的支持：==\u003ccontext: annotation-config/\u003e== \u003c?xm1 version=\"1. 0\" encoding=\"UTF-8\"?\u003e \u003cbeans xm7ns=\"http://www.springframework.org/ schema/beans\" xm1ns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xm1ns:context=\"http://www.springframework.org/schema/context\" xsi:schemalocati on=\"http: / /www. springf ramework. org/ schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springf ramework.org/schema/context https://www.springf ramework.org/schema/context/spring-context. xsd\"\u003e \u003c!--开启注解的支持--\u003e \u003ccontext: annotation-config/\u003e \u003c/beans\u003e| @Autowired 直接在属性上使用即可！也可以在set方式上使用！ 使用Autowired我们可以不用编写set方法了，前提是你这个自动装配的属性在IOC容器（Spring）容器中存在。且符合byName和byType 科普： @Nullable 字段标记了这个注解，说明这个字段可以为null public @interface Autowired { boolean required() default true; } 如果显示定义了Autowired的required属性为false,说明这个对象可以为null，否则不允许为空 @Autowired(rerequired = false) 测试代码 public class People { //如果显示定义了Autowi red的requi red属性为false，说明这个对象可以为nu11，否则不允许为空 @Autowired(required = false) private Cat cat; @Autowired private Dog dog; private String name; } 如果@Autowired自动装配的环境比较复杂，自动装配无法通过一个注解【@Autowired】完成的时候、我们可以使用@Qualifier(value=“xxx”)去配置@Autowired的使用，指定一个唯一的bean对象注入! pub1ic class People { @Autowired @Qualifier(va1ue=\"cat111\") private Cat cat; @Autowi red @Qualifier(va1ue=\"dog222\") private Dog dog; private String name; } @Resource注解 pub1ic class Peop1e { @Resource(name = \"cat2\") private Cat cat; @Resource private Dog dog; } jdk11没有@Resource 小结： autowired是先byteType,如果唯一則注入，否则byName查找。 resource是先byname,不符合再继续byType ","date":"2021-09-21","objectID":"/spring/:7:4","tags":["Spring","Mybatis"],"title":"Spring","uri":"/spring/"},{"categories":["框架"],"content":"8、使用注解开发 注解说明： @Autowired :自动装配通过类型。名字如果Autowired不能唯一自动装配 上属性，则需要通过@Qualifier(value=\" xxx\" ) @Nu1lable字段标记 了这个注解，说明这个字段可以为nu11; . @Resource:自动装配通过名字。类型。 @Component :组件，放在类上，说明这个类被Spring管理了，就是bean! 在Spring4之后，要使用注解开发，AOP的包必须导入 使用注解需要导入context约束，增加注解的支持！ bean 属性如何注入 //等价于 \u003cbean id=\"user\" class=\"com.miaobuyi.pojo.User\"/\u003e @Component public class User { //相当于\u003cproperty name=\"name\" value=\"喵不易\"/\u003e @Value(\"miaobuyi\") public String name; public void setName(String name) { this.name = name; } 衍生的注解 @Component有几个衍生注解，我们在web开发中，会按照mvc三层架构分层 dao【@Repository】 service【@Service】 controller【@Controller】 这四个注解功能都是一样的，都是代表将某个类注册到Spring中，装配Bean 自动装配 @Autowired :自动装配通过类型。名字如果Autowired不能唯一自动装配 上属性，则需要通过@Qualifier(value=\" xxx\" ) @Nu1lable字段标记 了这个注解，说明这个字段可以为nu11; . @Resource:自动装配通过名字。类型。 作用域 @Component @Scope(\"prototype\") public class User { //相当于\u003cproperty name=\"name\" value=\"喵不易\"/\u003e @Value(\"miaobuyi\") public String name; public void setName(String name) { this.name = name; } } 小结 xml与注解： xml更加万能，适用于任何场合！维护简单方便 注解，不是自己的类不能使用，维护相对复杂 xml与注解最佳实践： xml用来管理bean； 注解只负责完成属性的注入； 我们在使用的过程中，只需要注意一个问题：必须让注解生效，就需要开启注解支持 \u003c!--指定要扫描的包，这个包下的注解就会生效--\u003e \u003ccontext:component-scan base-package=\"com.miaobuyi\"/\u003e \u003ccontext:annotation-config/\u003e ","date":"2021-09-21","objectID":"/spring/:8:0","tags":["Spring","Mybatis"],"title":"Spring","uri":"/spring/"},{"categories":["框架"],"content":"9、使用java的方式配置Spring 我们现在要完全不使用Spring的xml配置了，全权交给java来做！ javaConfig是Spring的一个子项目，在Spring4之后，它成为了核心功能 实体类 package com.miaobuyi.pojo; import org.springframework.beans.factory.annotation.Value; import org.springframework.stereotype.Component; //这里这个注解的意思，就是说明这个类被Spring接管了，注册到了容器中 @Component public class User { @Value(\"miaobuyi\") private String name; public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String toString() { return \"User{\" + \"name='\" + name + '\\'' + '}'; } } 配置文件 package com.miaobuyi.config; import com.miaobuyi.pojo.User; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.Import; //这个也会Spring容器托管，注册到容器中，应为他本来就是一个@Component，@Configuration代表这是一个配置类，就和我们之前看的beans.xml一样的 @Configuration @ComponentScan(\"com.miaobuyi\") @Import(MyConfig2.class) public class MyConfig { //注册一个bean，就相当于我们之前的一个bean标签 //这个方法的名字，就相当于bean标签中的id属性 //这个方法的返回值，就相当于bean标签中的class属性 @Bean public User getUser(){ return new User();//就是要返回要注入到bean的对象 } } 测试类 import com.miaobuyi.config.MyConfig; import com.miaobuyi.pojo.User; import org.springframework.context.ApplicationContext; import org.springframework.context.annotation.AnnotationConfigApplicationContext; public class MyTest { //如果完全使用了配置类方式去做，我们就只能通过AnnotationConfig 上下文来获取容器，通过配置类的class对象加载 public static void main(String[] args) { ApplicationContext context = new AnnotationConfigApplicationContext(MyConfig.class); User user = context.getBean(\"getUser\", User.class); System.out.println(user.getName()); } } 这种纯java的配置方式，在SpringBoot中随处可见！ ","date":"2021-09-21","objectID":"/spring/:9:0","tags":["Spring","Mybatis"],"title":"Spring","uri":"/spring/"},{"categories":["框架"],"content":"10、代理模式 为什么要学习代理模式？因为这就是SpringAOP的底层！【SpringAOP和SpringMVC】 代理模式的分类： 静态代理 动态代理 ","date":"2021-09-21","objectID":"/spring/:10:0","tags":["Spring","Mybatis"],"title":"Spring","uri":"/spring/"},{"categories":["框架"],"content":"1、 静态代理 角色分析： 抽象角色：一般使用接口或者抽象类来解决 真实角色：被代理的角色 代理角色：代理真实角色，代理正式角色后，我们一般会做一些附属操作 客户：访问代理对象的人 代码步骤： 接口 package com.miaobuyi.demo01; //租房 public interface Rent { public void rent(); } 真实角色 package com.miaobuyi.demo01; //房东 public class Host implements Rent{ @Override public void rent() { System.out.println(\"房东要出租房子\"); } } 代理角色 package com.miaobuyi.demo01; public class Proxy implements Rent{ private Host host; public Proxy() { } public Proxy(Host host) { this.host = host; } @Override public void rent() { seeHouse(); host.rent(); hetong(); fare(); } //看房 public void seeHouse(){ System.out.println(\"中介带你看房\"); } //签合同 public void hetong(){ System.out.println(\"签合同\"); } //收中介费 public void fare(){ System.out.println(\"收中介费\"); } } 客户端访问代理角色 package com.miaobuyi.demo01; public class client { public static void main(String[] args) { //租客要租房子，需要一个房东 Host host = new Host(); //代理，中介帮租客租房子，但是，代理角色一般会有一些附属操作 Proxy proxy = new Proxy(host); //你不用面对房东直接找中介租房 proxy.rent(); } } 代理模式的好处： 可以使真实角色的操作更加纯粹！不用去关注一些公共的业务 公共也就交给了代理角色！实现了业务的分工！ 公共业务防身个拓展的时候，方便集中管理！ 缺点： 一个真实角色就会产生一个代理角色；代码量会翻~开发效率会贬变低 ","date":"2021-09-21","objectID":"/spring/:10:1","tags":["Spring","Mybatis"],"title":"Spring","uri":"/spring/"},{"categories":["框架"],"content":"2、加深理解 代码步骤： 接口 package com.miaobuyi.demo02; public interface UserService { public void add(); public void delete(); public void update(); public void query(); } 真实角色 package com.miaobuyi.demo02; //真实对象 public class UserServiceImpl implements UserService{ @Override public void add() { System.out.println(\"增加了一个用户\"); } @Override public void delete() { System.out.println(\"删除了一个用户\"); } @Override public void update() { System.out.println(\"修改了一个用户\"); } @Override public void query() { System.out.println(\"查询了一个用户\"); } //1.改动原有的业务代码，在公司中是大忌！ } 代理角色 package com.miaobuyi.demo02; public class UserServiceProxy implements UserService{ private UserServiceImpl userService; public void setUserService(UserServiceImpl userService) { this.userService = userService; } @Override public void add() { log(\"add\"); userService.add(); } @Override public void delete() { log(\"delete\"); userService.delete(); } @Override public void update() { log(\"update\"); userService.update(); } @Override public void query() { log(\"query\"); userService.query(); } //加一个日志方法 public void log(String msg){ System.out.println(\"[Debug] 使用了\"+msg+\"方法\"); } } 客户端访问代理角色 package com.miaobuyi.demo02; public class Client { public static void main(String[] args) { UserServiceImpl userService = new UserServiceImpl(); UserServiceProxy proxy = new UserServiceProxy(); proxy.setUserService(userService); proxy.add(); } } 聊聊AOP ","date":"2021-09-21","objectID":"/spring/:10:2","tags":["Spring","Mybatis"],"title":"Spring","uri":"/spring/"},{"categories":["框架"],"content":"3、动态代理 动态代理和静态代理角色一样 动态代理的代理类是动态生成的，不是我们写好的！ 动态代理可以分为两大类：基于接口的动态代理，基于类的动态代理 基于接口—JDK动态代理【我们在这里使用】 基于类—cglib Java字节码实现：javassist 需要了解两个类：Proxy：代理，InvocationHandler：调用处理程序 动态代理的好处： 可以使真实角色的操作更加纯粹！不用去关注一些公共的业务 公共也就交给了代理角色！实现了业务的分工！ 公共业务防身个拓展的时候，方便集中管理！ 一个动态代理类代理的是一个接口，一般对应的一类业务 一个动态代理类可以代理多个类，只要实现了同一个接口即可 ","date":"2021-09-21","objectID":"/spring/:10:3","tags":["Spring","Mybatis"],"title":"Spring","uri":"/spring/"},{"categories":["框架"],"content":"11、AOP 横向编程的思想，在不影响原来业务类的情况下实现动态增强 ","date":"2021-09-21","objectID":"/spring/:11:0","tags":["Spring","Mybatis"],"title":"Spring","uri":"/spring/"},{"categories":["框架"],"content":"1、什么是AOP AOP (Aspect Oriented Programming)意为:面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP 是OOP的延续,是软件开发中的一个热点,也是Spring框架中的一-个重要内容,是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 ","date":"2021-09-21","objectID":"/spring/:11:1","tags":["Spring","Mybatis"],"title":"Spring","uri":"/spring/"},{"categories":["框架"],"content":"2、Aop在Spring中的作用 ==提供声明式事务;允许用户自定义切面== 横切关注点:跨越应用程序多个模块的方法或功能。即是，与我们业务逻辑无关的，但是我们需要关注的部分，就是横切关注点。如日志，安全,缓存,事务等等… 切面(ASPECT) :横切关注点被模块化的特殊对象。即，它是一个类。 通知(Advice) :切面必须要完成的工作。即，它是类中的-一个方法。 目标(Target) :被通知对象。 代理(Proxy) :向目标对象应用通知之后创建的对象。 切入点(PointCut) :切面通知执行的“地点”的定义。 连接点(JointPoint) :与切入点匹配的执行点。 SpringAOP中，通过Advice定义横切逻辑，Spring中支持5中类型的Advice： 即AOP在不盖面原有代码的情况下，去增加新的功能 ","date":"2021-09-21","objectID":"/spring/:11:2","tags":["Spring","Mybatis"],"title":"Spring","uri":"/spring/"},{"categories":["框架"],"content":"3、使用Spring实现AOP 【重点】使用AOP织入，需要一个依赖包 \u003c!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.aspectj \u003c/groupId\u003e \u003cartifactId\u003easpectjweaver\u003c/artifactId\u003e \u003cversion\u003e1.9.4\u003c/version\u003e \u003c/dependency\u003e 方式一：使用Spring的API接口【主要是SpringAPI接口实现】 package com.miaobuyi.log; import org.springframework.aop.AfterReturningAdvice; import java.lang.reflect.Method; public class AfterLog implements AfterReturningAdvice { /** * * @param returnValue 返回值 * @param method * @param args * @param target * @throws Throwable */ @Override public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable { System.out.println(\"执行了\"+method.getName()+\"方法，返回结果为：\"+returnValue); } } package com.miaobuyi.log; import org.springframework.aop.MethodBeforeAdvice; import java.lang.reflect.Method; public class log implements MethodBeforeAdvice { //method:要执行的目标对象的方法 //args：参数 //target：目标对象 @Override public void before(Method method, Object[] objects, Object target) throws Throwable { System.out.println(target.getClass().getName()+\"的\"+method.getName()+\"被执行了\"); } } package com.miaobuyi.service; public interface UserService { public void add(); public void delete(); public void update(); public void select(); } package com.miaobuyi.service; public class UserServiceImpl implements UserService{ @Override public void add() { System.out.println(\"增加了一个用户\"); } @Override public void delete() { System.out.println(\"删除了一个用户\"); } @Override public void update() { System.out.println(\"更新了一个用户\"); } @Override public void select() { System.out.println(\"查询了一个用户\"); } } \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"\u003e \u003c!--注册bean--\u003e \u003cbean id=\"userService\" class=\"com.miaobuyi.service.UserServiceImpl\"/\u003e \u003cbean id=\"log\" class=\"com.miaobuyi.log.log\"/\u003e \u003cbean id=\"afterLog\" class=\"com.miaobuyi.log.AfterLog\"/\u003e \u003c!--方式一：使用Spring原生Spring API接口--\u003e \u003c!--配置aop:需要导入aop的约束--\u003e \u003caop:config\u003e \u003c!--切入点 expression:表达式,execution(要执行的位置！ * * * *)--\u003e \u003caop:pointcut id=\"pointcut\" expression=\"execution(* com.miaobuyi.service.UserServiceImpl.*(..))\"/\u003e \u003c!--执行环绕增强--\u003e \u003caop:advisor advice-ref=\"log\" pointcut-ref=\"pointcut\"/\u003e \u003caop:advisor advice-ref=\"afterLog\" pointcut-ref=\"pointcut\"/\u003e \u003c/aop:config\u003e \u003c/beans\u003e 方式二：自定义类来实现AOP【主要是切面定义】 package com.miaobuyi.diy; public class DiyPointCut { public void before(){ System.out.println(\"==========方法执行前==========\"); } public void after(){ System.out.println(\"==========方法执行后==========\"); } } \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"\u003e \u003c!--注册bean--\u003e \u003cbean id=\"userService\" class=\"com.miaobuyi.service.UserServiceImpl\"/\u003e \u003cbean id=\"log\" class=\"com.miaobuyi.log.log\"/\u003e \u003cbean id=\"afterLog\" class=\"com.miaobuyi.log.AfterLog\"/\u003e \u003c!--方式一：使用Spring原生Spring API接口--\u003e \u003c!--配置aop:需要导入aop的约束--\u003e \u003c!-- \u003caop:config\u003e--\u003e \u003c!-- \u0026lt;!\u0026ndash;切入点 expression:表达式,execution(要执行的位置！ * * * *)\u0026ndash;\u0026gt;--\u003e \u003c!-- \u003caop:pointcut id=\"pointcut\" expression=\"execution(* com.miaobuyi.service.UserServiceImpl.*(..))\"/\u003e--\u003e \u003c!-- \u0026lt;!\u0026ndash;执行环绕增强\u0026ndash;\u0026gt;--\u003e \u003c!-- \u003caop:advisor advice-ref=\"log\" pointcut-ref=\"pointcut\"/\u003e--\u003e \u003c!-- \u003caop:advisor advice-ref=\"afterLog\" pointcut-ref=\"pointcut\"/\u003e--\u003e \u003c!-- \u003c/aop:config\u003e--\u003e \u003c!--方式二：自定义类--\u003e \u003cbean id=\"diyPointCut\" class=\"com.miaobuyi.diy.DiyPointCut\"/\u003e \u003caop:config\u003e \u003c!--自定义切面，ref ","date":"2021-09-21","objectID":"/spring/:11:3","tags":["Spring","Mybatis"],"title":"Spring","uri":"/spring/"},{"categories":["框架"],"content":"12、整合Mybatis 步骤： 导入相关jar包 junit mybatis mysql数据库 Spring相关的 aop织入 mybatis-Spring【new】 \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003ejunit\u003c/groupId\u003e \u003cartifactId\u003ejunit\u003c/artifactId\u003e \u003cversion\u003e4.13\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003cversion\u003e8.0.25\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis\u003c/groupId\u003e \u003cartifactId\u003emybatis\u003c/artifactId\u003e \u003cversion\u003e3.5.7\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-webmvc\u003c/artifactId\u003e \u003cversion\u003e5.3.9\u003c/version\u003e \u003c/dependency\u003e \u003c!--Spring操作数据库的话还需要一个spring-jdbc--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-jdbc\u003c/artifactId\u003e \u003cversion\u003e5.3.8\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.aspectj\u003c/groupId\u003e \u003cartifactId\u003easpectjweaver\u003c/artifactId\u003e \u003cversion\u003e1.9.7\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis\u003c/groupId\u003e \u003cartifactId\u003emybatis-spring\u003c/artifactId\u003e \u003cversion\u003e2.0.6\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e 编写配置文件 测试 ","date":"2021-09-21","objectID":"/spring/:12:0","tags":["Spring","Mybatis"],"title":"Spring","uri":"/spring/"},{"categories":["框架"],"content":"1、回忆Mybatis 编写实体类 编写核心配置文件 编写接口 编写Mapper.xml 测试 ","date":"2021-09-21","objectID":"/spring/:12:1","tags":["Spring","Mybatis"],"title":"Spring","uri":"/spring/"},{"categories":["框架"],"content":"2、Mybatis-spring 编写数据源 sqlSessionFactory sqlSessionTemplate 需要给接口加实现类【】 将自己写的实现类，注入到Spring中 测试使用即可 spring-dao.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"\u003e \u003c!--DataSource：使用Spring的数据源替换Mybatis的配置 c3p0 dbcp druid 我们这里使用Spring提供的JDBC --\u003e \u003cbean id=\"datasource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"\u003e \u003cproperty name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\"/\u003e \u003cproperty name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis?useSSL=true\u0026amp;useUnicode=true\u0026amp;characterEncoding=UTF-8\"/\u003e \u003cproperty name=\"username\" value=\"root\"/\u003e \u003cproperty name=\"password\" value=\"123456\"/\u003e \u003c/bean\u003e \u003c!--SqlSessionFactory--\u003e \u003cbean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"\u003e \u003cproperty name=\"dataSource\" ref=\"datasource\"/\u003e \u003c!--绑定mybatis配置文件--\u003e \u003cproperty name=\"configLocation\" value=\"classpath:mybatis-config.xml\"/\u003e \u003cproperty name=\"mapperLocations\" value=\"classpath:com/miaobuyi/mapper/UserMapper.xml\"/\u003e \u003c/bean\u003e \u003c!--SqlSessionTemplate:就是我们使用的sqlSession--\u003e \u003cbean id=\"sqlSession\" class=\"org.mybatis.spring.SqlSessionTemplate\"\u003e \u003c!--只能使用构造器注入sqlSessionFactory，因为他没有set方法--\u003e \u003cconstructor-arg index=\"0\" ref=\"sqlSessionFactory\"/\u003e \u003c/bean\u003e \u003c!----\u003e \u003cbean id=\"UserMapper\" class=\"com.miaobuyi.mapper.UserMapperImpl\"\u003e \u003cproperty name=\"sqlSession\" ref=\"sqlSession\"\u003e\u003c/property\u003e \u003c/bean\u003e \u003c/beans\u003e applicationContext.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"\u003e \u003cimport resource=\"spring-dao.xml\"/\u003e \u003c!----\u003e \u003cbean id=\"UserMapper\" class=\"com.miaobuyi.mapper.UserMapperImpl\"\u003e \u003cproperty name=\"sqlSession\" ref=\"sqlSession\"\u003e\u003c/property\u003e \u003c/bean\u003e \u003c/beans\u003e UserMapperImpl.java package com.miaobuyi.mapper; import com.miaobuyi.pojo.User; import org.mybatis.spring.SqlSessionTemplate; import java.util.List; public class UserMapperImpl implements UserMapper{ //我们所有操作，在原来都使用sqlSession来执行，现在都使用SqlSessionTemplate private SqlSessionTemplate sqlSession; public void setSqlSession(SqlSessionTemplate sqlSession) { this.sqlSession = sqlSession; } @Override public List\u003cUser\u003e selectUser() { UserMapper mapper = sqlSession.getMapper(UserMapper.class); return mapper.selectUser(); } } UserMapper.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"\u003e \u003cmapper namespace=\"com.miaobuyi.mapper.UserMapper\"\u003e \u003cselect id=\"selectUser\" resultType=\"user\"\u003e select * from mybatis.user \u003c/select\u003e \u003c/mapper\u003e UserMapper.java package com.miaobuyi.mapper; import com.miaobuyi.pojo.User; import java.util.List; public interface UserMapper { public List\u003cUser\u003e selectUser(); } 测试 import com.miaobuyi.mapper.UserMapper; import com.miaobuyi.pojo.User; import org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import org.junit.Test; import org.springframework.context.support.ClassPathXmlApplicationContext; import java.io.IOException; import java.io.InputStream; import java.util.List; public class MyTest { @Test public void test() throws IOException { ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"spring-dao.xml\"); UserMapper userMapper = context.getBean(\"UserMapper\", Use","date":"2021-09-21","objectID":"/spring/:12:2","tags":["Spring","Mybatis"],"title":"Spring","uri":"/spring/"},{"categories":["框架"],"content":"13、声明式事务 ","date":"2021-09-21","objectID":"/spring/:13:0","tags":["Spring","Mybatis"],"title":"Spring","uri":"/spring/"},{"categories":["框架"],"content":"1、回顾事务 把一组业务当成一个业务来做：要么都成功，要么都失败！ 事务在项目开发中，十分的重要，涉及到数据的一致性问题，不能马虎！ 确保完整性和一致性 事务ACID原则： 原子性 一致性 隔离性 多个业务可能操作同一个资源，防止数据损坏 持久性 事务一旦体检，无论系统发生什么问题，结果都不会再被影响，被持久化的写到存储器中！ 2、Spring当中的事务管理 声明式事务：AOP 编程式事务：需要在代码中，进行事务的管理 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\"\u003e \u003c!--DataSource：使用Spring的数据源替换Mybatis的配置 c3p0 dbcp druid 我们这里使用Spring提供的JDBC --\u003e \u003cbean id=\"datasource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"\u003e \u003cproperty name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\"/\u003e \u003cproperty name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis?useSSL=true\u0026amp;useUnicode=true\u0026amp;characterEncoding=UTF-8\"/\u003e \u003cproperty name=\"username\" value=\"root\"/\u003e \u003cproperty name=\"password\" value=\"123456\"/\u003e \u003c/bean\u003e \u003c!--SqlSessionFactory--\u003e \u003cbean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"\u003e \u003cproperty name=\"dataSource\" ref=\"datasource\"/\u003e \u003c!--绑定mybatis配置文件--\u003e \u003cproperty name=\"configLocation\" value=\"classpath:mybatis-config.xml\"/\u003e \u003cproperty name=\"mapperLocations\" value=\"classpath:com/miaobuyi/mapper/UserMapper.xml\"/\u003e \u003c/bean\u003e \u003c!--SqlSessionTemplate:就是我们使用的sqlSession--\u003e \u003cbean id=\"sqlSession\" class=\"org.mybatis.spring.SqlSessionTemplate\"\u003e \u003c!--只能使用构造器注入sqlSessionFactory，因为他没有set方法--\u003e \u003cconstructor-arg index=\"0\" ref=\"sqlSessionFactory\"/\u003e \u003c/bean\u003e \u003c!--配置声明式事务--\u003e \u003cbean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"\u003e \u003cconstructor-arg ref=\"datasource\"/\u003e \u003c/bean\u003e \u003c!--结合AOP实现事务的织入--\u003e \u003c!--配置事务通知--\u003e \u003ctx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\"\u003e \u003c!--给那些方法配置事务--\u003e \u003c!--配置事务的传播特性：new propagation= --\u003e \u003ctx:attributes\u003e \u003ctx:method name=\"add\" propagation=\"REQUIRED\"/\u003e \u003ctx:method name=\"delete\" propagation=\"REQUIRED\"/\u003e \u003ctx:method name=\"update\" propagation=\"REQUIRED\"/\u003e \u003ctx:method name=\"query\" read-only=\"true\"/\u003e \u003ctx:method name=\"*\" propagation=\"REQUIRED\"/\u003e \u003c/tx:attributes\u003e \u003c/tx:advice\u003e \u003c!--配置事务切入--\u003e \u003caop:config\u003e \u003caop:pointcut id=\"txPoint\" expression=\"execution(* com.miaobuyi.mapper.*.*(..))\"/\u003e \u003caop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"txPoint\"/\u003e \u003c/aop:config\u003e \u003c/beans\u003e 思考： 为什么需要事务？ 如果不配置事务，可能存在数据提交不一致的情况下； 如果我们不在Spring中去配置声明式事务，我们就需要在代码中手动配置事务！ 事务在项目的开发中十分重要，涉及到数据的一致性和完整性问题，不容马虎 ","date":"2021-09-21","objectID":"/spring/:13:1","tags":["Spring","Mybatis"],"title":"Spring","uri":"/spring/"}]